{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NPDateTime","text":"<p>High-performance Nepali (Bikram Sambat) datetime library for Rust and beyond.</p> <p> </p> <p>NPDateTime is a modern, fast, and accurate library for working with the Bikram Sambat (BS) calendar. It uniquely combines the speed of lookup tables with the precision of astronomical calculations.</p> <p>This version achieves 100% feature parity with the original Python npdatetime library, while adding an advanced high-precision astronomical engine.</p>"},{"location":"#key-design-decisions","title":"\ud83c\udf1f Key Design Decisions","text":"<ul> <li>Hybrid Engine: Use <code>lookup-tables</code> for historical accuracy (1975-2100 BS) or <code>astronomical</code> for high-precision calculations based on VSOP87 and ELP-2000 theories.</li> <li>Zero Overhead: Minimal dependencies and <code>no_std</code> compatibility for embedded systems.</li> <li>Feature Flags: Take only what you need. Small binary size by default.</li> <li>Reliability: Verified against official government calendars and astronomical ephemeris.</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nnpdatetime = \"0.1.0\"\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>use npdatetime::prelude::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Create a Nepali Date\n    let date = NepaliDate::new(2081, 1, 1)?;\n    println!(\"Standard BS: {}\", date);\n\n    // Convert to Gregorian\n    let (year, month, day) = date.to_gregorian()?;\n    println!(\"AD Date: {}-{:02}-{:02}\", year, month, day);\n\n    Ok(())\n}\n</code></pre>"},{"location":"#astronomical-calculations","title":"Astronomical Calculations","text":"<p>Enable the <code>astronomical</code> feature to access high-precision tools:</p> <pre><code>#[cfg(feature = \"astronomical\")]\n{\n    let cal = AstronomicalCalendar::new();\n    let info = cal.get_year_info(2081)?;\n    println!(\"Months: {:?}\", info.month_lengths);\n}\n</code></pre>"},{"location":"#feature-flags","title":"\ud83d\udee0 Feature Flags","text":"Feature Description Default <code>lookup-tables</code> Embedded CSV data (1975-2100 BS) Yes <code>astronomical</code> High-precision solar/lunar models No <code>std</code> Standard library features (Chrono) No <code>wasm</code> JS/WASM interop support No <code>python</code> PyO3 bindings No"},{"location":"#performance","title":"\ud83d\udcca Performance","text":"<p>NPDateTime achieves exceptional performance through compile-time CSV embedding:</p> Operation Time Notes <code>days_in_month</code> 9-12 ns Lookup table access Date creation 12 ns Validates and constructs BS \u2194 AD conversion 6-8 \u00b5s Full date conversion Format operations 98-640 ns strftime-style formatting <p>Benchmarks on Rust 1.92, release mode</p>"},{"location":"#multi-language-support","title":"\ud83c\udf0d Multi-Language Support","text":"<p>NPDateTime provides official bindings for multiple languages:</p>"},{"location":"#python-pyo3","title":"Python (PyO3)","text":"<pre><code>pip install npdatetime\n</code></pre> <pre><code>from npdatetime import NepaliDate\n\ndate = NepaliDate(2077, 5, 19)\nyear, month, day = date.to_gregorian()\nprint(f\"{year}-{month:02d}-{day:02d}\")  # 2020-09-04\n</code></pre>"},{"location":"#javascriptwasm","title":"JavaScript/WASM","text":"<pre><code>npm install npdatetime-wasm\n</code></pre> <pre><code>import init, { NepaliDate } from 'npdatetime-wasm';\nawait init();\n\nconst date = new NepaliDate(2077, 5, 19);\nconst [year, month, day] = date.toGregorian();\nconsole.log(`${year}-${month}-${day}`);  // 2020-9-4\n</code></pre> <p>See <code>bindings/</code> for detailed setup and API documentation.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>CHANGELOG: Release notes and version history.</li> <li>CONTRIBUTING: How to contribute.</li> <li>SECURITY: Security policy and vulnerability reporting.</li> <li>Roadmap: Future plans and progress.</li> <li>Development Guide: Architecture and coding standards.</li> <li>Astronomy Theory: The math behind calculations.</li> <li>Project Structure: Codebase layout.</li> </ul>"},{"location":"#project-structure","title":"\ud83d\udcc2 Project Structure","text":"<ul> <li><code>src/core/</code>: Shared types (<code>NepaliDate</code>, error handling, formatting).</li> <li><code>src/lookup/</code>: Fast table-based calendar logic (1975-2100 BS).</li> <li><code>src/astronomical/</code>: High-precision solar (VSOP87) and lunar (ELP-2000) calculations.</li> <li><code>bindings/python/</code>: PyO3 bindings for Python.</li> <li><code>bindings/javascript/</code>: wasm-bindgen bindings for JavaScript/WASM.</li> <li><code>examples/</code>: Usage examples and demonstrations.</li> <li><code>benches/</code>: Performance benchmarks.</li> </ul>"},{"location":"#testing","title":"\ud83e\uddea Testing","text":"<pre><code># Run all tests\ncargo test\n\n# Run with all features\ncargo test --all-features\n\n# Run benchmarks\ncargo bench\n</code></pre> <p>Test Coverage: 67 tests, 100% passing</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"ASTRONOMY/","title":"Astronomical Theory &amp; Implementation","text":""},{"location":"ASTRONOMY/#the-theory-astronomical-calculation-is-possible","title":"\u2705 The Theory: Astronomical Calculation IS Possible","text":"<p>The Chinese calendar is based on calculations of the positions of the Sun and Moon, and astronomical phenomena require mathematically correlating solar and lunar cycles from Earth's perspective. The same can be done for Bikram Sambat.</p>"},{"location":"ASTRONOMY/#how-it-would-work","title":"How It Would Work","text":"<p>The Bikram Sambat calendar follows these astronomical rules:</p> <ol> <li>Solar Component: Year divisions based on Sun's position in zodiac (Sankranti)</li> <li>Lunar Component: Months based on Moon phases (Tithi)</li> <li>Synchronization: Leap months added to keep solar and lunar in sync</li> </ol>"},{"location":"ASTRONOMY/#core-astronomical-calculations-required","title":"Core Astronomical Calculations Required","text":"<pre><code>// Theoretical Implementation\n\n// 1. Calculate Sun's Longitude (Solar Position)\nfn sun_longitude(julian_day: f64) -&gt; f64 {\n    // Using VSOP87 or similar planetary theory\n    // Returns longitude in degrees (0-360)\n    // Accuracy needed: ~0.04 arcseconds\n}\n\n// 2. Calculate Moon's Longitude (Lunar Position)  \nfn moon_longitude(julian_day: f64) -&gt; f64 {\n    // Using ELP-2000 or Chapront lunar theory\n    // Returns longitude in degrees (0-360)\n    // Accuracy needed: ~0.5 arcseconds\n}\n\n// 3. Calculate Tithi (Lunar Day)\nfn calculate_tithi(julian_day: f64) -&gt; u8 {\n    let sun_long = sun_longitude(julian_day);\n    let moon_long = moon_longitude(julian_day);\n\n    // Tithi = (Moon longitude - Sun longitude) / 12\u00b0\n    let tithi_deg = (moon_long - sun_long).rem_euclid(360.0);\n    let tithi = (tithi_deg / 12.0).floor() as u8 + 1;\n\n    // Returns 1-30 (30 tithis per month)\n    tithi\n}\n\n// 4. Calculate Sankranti (Solar Month Transition)\nfn calculate_sankranti(year: i32, month: u8) -&gt; f64 {\n    // Find when Sun enters next zodiac sign (every 30\u00b0)\n    let target_longitude = (month as f64 - 1.0) * 30.0;\n\n    // Use Newton-Raphson or bisection to find exact time\n    find_solar_event(year, target_longitude)\n}\n\n// 5. Determine Month Length\nfn bs_month_days(year: i32, month: u8) -&gt; u8 {\n    let start_jd = month_start_julian_day(year, month);\n    let end_jd = month_start_julian_day(year, month + 1);\n\n    (end_jd - start_jd).round() as u8\n}\n</code></pre>"},{"location":"ASTRONOMY/#the-astronomical-formulas","title":"\ud83d\udd2c The Astronomical Formulas","text":""},{"location":"ASTRONOMY/#1-synodic-month-lunar-phase-cycle","title":"1. Synodic Month (Lunar Phase Cycle)","text":"<p>The synodic month based on lunar theory is 29.530588853 days, with corrections for long-term variations:</p> <pre><code>Synodic Month = 29.530588853 + 0.00000021621*T - 3.64\u00d710\u207b\u00b9\u2070*T\u00b2\nwhere T = centuries since J2000.0\n</code></pre>"},{"location":"ASTRONOMY/#2-tropical-year-solar-cycle","title":"2. Tropical Year (Solar Cycle)","text":"<p>The tropical year is 365.24218967 days with similar corrections:</p> <pre><code>Tropical Year = 365.24218967 - 0.00000615359*T - 7.29\u00d710\u207b\u00b9\u2070*T\u00b2\n</code></pre>"},{"location":"ASTRONOMY/#3-metonic-cycle","title":"3. Metonic Cycle","text":"<p>The Metonic cycle shows that 235 lunar months equal 19 solar years, which helps predict leap months:</p> <pre><code>235 synodic months \u2248 19 tropical years \u2248 6939.6 days\n</code></pre>"},{"location":"ASTRONOMY/#real-implementation-example","title":"\ud83d\udcbb Real Implementation Example","text":"<p>Here's how you could actually implement it:</p> <pre><code>use std::f64::consts::PI;\n\n/// Calculate Sun's mean longitude using simplified formula\nfn sun_mean_longitude(jde: f64) -&gt; f64 {\n    // JDE = Julian Ephemeris Day\n    let t = (jde - 2451545.0) / 36525.0; // Centuries since J2000.0\n\n    // Mean longitude of Sun (simplified)\n    let l0 = 280.46646 + 36000.76983 * t + 0.0003032 * t * t;\n\n    l0.rem_euclid(360.0)\n}\n\n/// Calculate Moon's mean longitude\nfn moon_mean_longitude(jde: f64) -&gt; f64 {\n    let t = (jde - 2451545.0) / 36525.0;\n\n    // Mean longitude of Moon (simplified)\n    let l = 218.3164477 + 481267.88123421 * t \n            - 0.0015786 * t * t + t * t * t / 538841.0 \n            - t * t * t * t / 65194000.0;\n\n    l.rem_euclid(360.0)\n}\n\n/// Calculate when Sun enters a zodiac sign (Sankranti)\nfn find_sankranti(year: i32, zodiac_sign: u8) -&gt; f64 {\n    let target_longitude = (zodiac_sign as f64 - 1.0) * 30.0;\n\n    // Initial guess: approximate date\n    let mut jd = gregorian_to_jd(year, 1, 1);\n\n    // Newton-Raphson iteration\n    for _ in 0..10 {\n        let sun_long = sun_mean_longitude(jd);\n        let diff = (target_longitude - sun_long + 180.0).rem_euclid(360.0) - 180.0;\n\n        if diff.abs() &lt; 0.0001 {\n            break;\n        }\n\n        // Sun moves ~1\u00b0 per day\n        jd += diff;\n    }\n\n    jd\n}\n\n/// Determine BS month length astronomically\npub fn calculate_bs_month_length(year: i32, month: u8) -&gt; u8 {\n    // Find start of this month (solar event)\n    let start_jd = find_sankranti(year, month);\n\n    // Find start of next month\n    let end_jd = find_sankranti(year, month + 1);\n\n    // Number of days\n    (end_jd - start_jd).round() as u8\n}\n</code></pre>"},{"location":"ASTRONOMY/#why-this-isnt-used-in-practice","title":"\u26a0\ufe0f Why This Isn't Used in Practice","text":""},{"location":"ASTRONOMY/#problem-1-extreme-precision-required","title":"Problem 1: Extreme Precision Required","text":"<p>To calculate solar terms within one second requires Sun position accuracy better than 0.04 arcseconds, and Moon position requires 0.5 arcseconds - accuracy not achieved until the late 1970s.</p> <p>What this means: - Modern GPS satellites: ~1 meter accuracy - Required astronomical precision: equivalent to measuring distance to Moon within 2 meters!</p>"},{"location":"ASTRONOMY/#problem-2-computational-complexity","title":"Problem 2: Computational Complexity","text":"<pre><code>// Simple version: ~100 lines\n// Accurate version: ~10,000 lines of astronomical formulas\n\n// You'd need to implement:\n- VSOP87 planetary theory (Sun position)\n- ELP-2000/82 lunar theory (Moon position)\n- Nutation calculations\n- Light-time corrections\n- Topocentric corrections (observer location)\n- Atmospheric refraction\n- Precession of equinoxes\n</code></pre>"},{"location":"ASTRONOMY/#problem-3-historical-compatibility","title":"Problem 3: Historical Compatibility","text":"<p>Even with perfect calculations, you'd get different results than published calendars because:</p> <ol> <li>Traditional calculations use older astronomical models</li> <li>Observation-based adjustments for weather, visibility</li> <li>Cultural rules override pure astronomy (postponement rules)</li> <li>Historical data was calculated with less precise methods</li> </ol>"},{"location":"ASTRONOMY/#problem-4-computational-cost","title":"Problem 4: Computational Cost","text":"<pre><code>Lookup table: ~1 nanosecond\nAstronomical calculation: ~1 millisecond (1,000,000x slower!)\n</code></pre>"},{"location":"ASTRONOMY/#practical-hybrid-approach","title":"\ud83c\udfaf Practical Hybrid Approach","text":"<p>Instead of pure calculation OR pure lookup, you could do both:</p> <pre><code>pub struct BsCalendar {\n    // Lookup table for verified historical data (2000-2090)\n    verified_data: HashMap&lt;(i32, u8), u8&gt;,\n\n    // Astronomical calculator for future dates\n    astronomical_calc: AstronomicalCalculator,\n}\n\nimpl BsCalendar {\n    pub fn days_in_month(&amp;self, year: i32, month: u8) -&gt; u8 {\n        // Use lookup for verified years\n        if year &gt;= 2000 &amp;&amp; year &lt;= 2090 {\n            self.verified_data[&amp;(year, month)]\n        } \n        // Use calculation for future years\n        else {\n            self.astronomical_calc.calculate(year, month)\n        }\n    }\n}\n</code></pre>"},{"location":"ASTRONOMY/#libraries-that-do-this","title":"\ud83d\udcda Libraries That Do This","text":"<p>Some calendars already use astronomical calculations:</p> <ol> <li>Chinese Calendar: Modern implementations calculate positions</li> <li>Hebrew Calendar: Uses algorithmic approximations</li> <li>Islamic Calendar: Some variants use astronomical calculations</li> </ol>"},{"location":"ASTRONOMY/#example-chinese-calendar-implementation","title":"Example: Chinese Calendar Implementation","text":"<p>The Chinese calendar uses astronomical observations and calculations to correlate solar and lunar cycles.</p> <p>Modern software like PyMeeus and Astronomia provide these calculations.</p>"},{"location":"ASTRONOMY/#if-you-want-to-implement-it","title":"\ud83d\ude80 If You Want to Implement It","text":"<p>Here's what you'd need:</p>"},{"location":"ASTRONOMY/#option-1-use-existing-astronomical-library","title":"Option 1: Use Existing Astronomical Library","text":"<pre><code>// Use existing Rust astronomy crates\nuse astro::{sun, moon, time};\n\npub fn calculate_bs_date_astronomical(year: i32, month: u8) -&gt; u8 {\n    let sankranti = sun::find_zodiac_entry(year, month);\n    let next_sankranti = sun::find_zodiac_entry(year, month + 1);\n\n    (next_sankranti - sankranti).days()\n}\n</code></pre> <p>Rust astronomy crates: - <code>astro</code> - Basic astronomical calculations - <code>vsop87</code> - High-precision planetary positions - <code>elp-mpp02</code> - Lunar position calculations</p>"},{"location":"ASTRONOMY/#option-2-use-python-astronomical-libraries","title":"Option 2: Use Python Astronomical Libraries","text":"<pre><code>from skyfield.api import load\nfrom datetime import datetime\n\ndef calculate_bs_month_length(year, month):\n    ts = load.timescale()\n    planets = load('de421.bsp')  # JPL ephemeris\n\n    earth = planets['earth']\n    sun = planets['sun']\n\n    # Find when sun enters zodiac sign\n    # ... complex calculations ...\n\n    return days_in_month\n</code></pre>"},{"location":"ASTRONOMY/#the-truth","title":"\ud83c\udf93 The Truth","text":"<p>Yes, it's theoretically possible, but:</p> <ol> <li>\u2705 For research/verification: Calculate to verify lookup tables</li> <li>\u2705 For future years: Generate data beyond 2090</li> <li>\u2705 For education: Understand calendar mechanics</li> <li>\u274c For production: Use lookup tables (faster, verified, compatible)</li> </ol>"},{"location":"ASTRONOMY/#recommended-approach","title":"\ud83d\udca1 Recommended Approach","text":"<pre><code>// BEST OF BOTH WORLDS\n\npub struct NpdatetimeFull {\n    // Fast lookup for known years\n    lookup: BsLookupTable,\n\n    // Astronomical calculator for future\n    astro: Option&lt;AstronomicalCalculator&gt;,\n}\n\nimpl NpdatetimeFull {\n    // Fast path: use lookup\n    pub fn new() -&gt; Self {\n        Self {\n            lookup: BsLookupTable::embedded(),\n            astro: None,\n        }\n    }\n\n    // Full path: with astronomical calculations\n    pub fn with_astronomical() -&gt; Self {\n        Self {\n            lookup: BsLookupTable::embedded(),\n            astro: Some(AstronomicalCalculator::new()),\n        }\n    }\n\n    pub fn days_in_month(&amp;self, year: i32, month: u8) -&gt; Result&lt;u8&gt; {\n        // Try lookup first\n        if let Some(days) = self.lookup.get(year, month) {\n            return Ok(days);\n        }\n\n        // Fall back to calculation\n        if let Some(ref calc) = self.astro {\n            return calc.calculate_month_days(year, month);\n        }\n\n        Err(\"Year out of range and astronomical calculator not available\")\n    }\n}\n</code></pre> <p>This gives you: - \u26a1 Fast lookups for 2000-2090 (99% of use cases) - \ud83d\udd2d Astronomical calculations for research and future dates - \ud83c\udfaf Best of both worlds</p>"},{"location":"ASTRONOMY/#references-for-implementation","title":"\ud83d\udcd6 References for Implementation","text":"<p>If you want to try implementing astronomical calculations:</p> <ol> <li>Jean Meeus - \"Astronomical Algorithms\" (the bible of calendar calculations)</li> <li>Skyfield (Python) - Modern astronomical library</li> <li>VSOP87 - Planetary position theory</li> <li>ELP-2000 - Lunar position theory</li> <li>The Astronomical Almanac - Reference ephemeris data</li> </ol> <p>Bottom line: It's possible and fascinating, but for a production library serving users, lookup tables are the right choice. Use astronomical calculations for verification and future-proofing, not as the primary method.</p>"},{"location":"DEVELOPMENT_GUIDE/","title":"Development Guidelines","text":""},{"location":"DEVELOPMENT_GUIDE/#npdatetime-astronomical-calculator-for-bikram-sambat","title":"NPDateTime Astronomical Calculator for Bikram Sambat","text":"<p>Version: 1.0 Last Updated: January 2026 Purpose: Astronomical calculation of Bikram Sambat calendar dates based on solar and lunar positions</p>"},{"location":"DEVELOPMENT_GUIDE/#table-of-contents","title":"\ud83d\udccb Table of Contents","text":"<ol> <li>Project Overview</li> <li>Architecture Principles</li> <li>Module Implementation Order</li> <li>Code Standards</li> <li>Mathematical Foundations</li> <li>Implementation Details</li> <li>Testing Strategy</li> <li>Performance Requirements</li> <li>Validation Process</li> <li>Common Pitfalls</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#1-project-overview","title":"1. Project Overview","text":""},{"location":"DEVELOPMENT_GUIDE/#11-goals","title":"1.1 Goals","text":"<p>Primary Goal: Calculate Bikram Sambat calendar dates using astronomical positions of Sun and Moon</p> <p>Secondary Goals: - Validate existing lookup table data - Generate future calendar data (beyond 2090 BS) - Provide educational tool for understanding BS calendar mechanics - Research tool for calendar scientists</p>"},{"location":"DEVELOPMENT_GUIDE/#12-non-goals","title":"1.2 Non-Goals","text":"<ul> <li>\u274c Replace lookup tables for production use (too slow)</li> <li>\u274c Provide real-time astronomical observations</li> <li>\u274c Calculate for dates before 2000 BS (insufficient historical data)</li> <li>\u274c Support other calendar systems</li> </ul>"},{"location":"DEVELOPMENT_GUIDE/#13-success-criteria","title":"1.3 Success Criteria","text":"<ul> <li>\u2705 Match known Sankranti times within \u00b110 seconds</li> <li>\u2705 Match lookup table month lengths 100% for 2000-2090 BS</li> <li>\u2705 Calculate month length in &lt; 50ms</li> <li>\u2705 Work without network/external dependencies</li> </ul>"},{"location":"DEVELOPMENT_GUIDE/#2-architecture-principles","title":"2. Architecture Principles","text":""},{"location":"DEVELOPMENT_GUIDE/#21-separation-of-concerns","title":"2.1 Separation of Concerns","text":"<p>RULE 1: Keep astronomical calculations separate from calendar logic</p> <pre><code>// CORRECT: Separation\nlet sun_longitude = solar::position::calculate(jd);\nlet month_start = calendar::find_month_start(sun_longitude);\n\n// WRONG: Mixed concerns\nlet month_start = calculate_month_start_with_sun_position(jd);\n</code></pre> <p>RULE 2: Time conversions in one place only (<code>core::time</code>)</p> <pre><code>// CORRECT: Centralized\nuse crate::core::time::JulianDay;\nlet jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n\n// WRONG: Scattered conversions\nlet jd = year * 365.25 + month * 30.0; // Don't do this!\n</code></pre> <p>RULE 3: Constants defined once in <code>core::constants</code></p> <pre><code>// CORRECT: Use constants\nuse crate::core::constants::ZODIAC_DEGREES;\nlet sign_boundary = sign_number as f64 * ZODIAC_DEGREES;\n\n// WRONG: Magic numbers\nlet sign_boundary = sign_number as f64 * 30.0; // What is 30?\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#22-modularity","title":"2.2 Modularity","text":"<p>Each module must be independently testable:</p> <pre><code>// Solar module works alone\n#[test]\nfn test_solar_position() {\n    let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n    let longitude = SolarCalculator::true_longitude(jd);\n    assert!(longitude &gt;= 0.0 &amp;&amp; longitude &lt; 360.0);\n}\n\n// Lunar module works alone\n#[test]\nfn test_lunar_position() {\n    let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n    let longitude = LunarCalculator::true_longitude(jd);\n    assert!(longitude &gt;= 0.0 &amp;&amp; longitude &lt; 360.0);\n}\n\n// Calendar module uses both\n#[test]\nfn test_tithi() {\n    let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n    let tithi = calculate_tithi(jd);\n    assert!(tithi &gt;= 1 &amp;&amp; tithi &lt;= 30);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#23-feature-flags","title":"2.3 Feature Flags","text":"<p>RULE 4: Support multiple accuracy levels</p> <pre><code>[features]\ndefault = [\"simple\"]\nsimple = []           # Fast, \u00b110 second accuracy\nhigh-precision = []   # Slow, \u00b11 second accuracy\nvalidation = [\"serde\"] # For comparing with lookup tables\n</code></pre> <pre><code>// Implementation\n#[cfg(feature = \"simple\")]\npub fn sun_longitude(jd: JulianDay) -&gt; f64 {\n    // Simplified 10-term series\n}\n\n#[cfg(feature = \"high-precision\")]\npub fn sun_longitude(jd: JulianDay) -&gt; f64 {\n    // Full VSOP87 with 100+ terms\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#3-module-implementation-order","title":"3. Module Implementation Order","text":""},{"location":"DEVELOPMENT_GUIDE/#phase-1-foundation-week-1","title":"Phase 1: Foundation (Week 1)","text":"<p>Priority: CRITICAL - DO THIS FIRST</p>"},{"location":"DEVELOPMENT_GUIDE/#311-implement-srccoretimers","title":"3.1.1 Implement <code>src/core/time.rs</code>","text":"<p>Status: \u2705 Already provided in project setup</p> <p>Validation Tests:</p> <pre><code>#[test]\nfn test_j2000_epoch() {\n    let jd = JulianDay::from_gregorian(2000, 1, 1, 12.0);\n    assert_eq!(jd.0, 2451545.0);\n}\n\n#[test]\nfn test_bs_epoch() {\n    // 2000 Baisakh 1 = 1943 April 14\n    let jd = JulianDay::from_gregorian(1943, 4, 14, 0.0);\n    let (y, m, d, _) = jd.to_gregorian();\n    assert_eq!((y, m, d), (1943, 4, 14));\n}\n\n#[test]\nfn test_round_trip() {\n    let jd1 = JulianDay::from_gregorian(2020, 4, 14, 6.5);\n    let (y, m, d, h) = jd1.to_gregorian();\n    let jd2 = JulianDay::from_gregorian(y, m, d, h);\n    assert!((jd1.0 - jd2.0).abs() &lt; 0.0001);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#312-implement-srccoreconstantsrs","title":"3.1.2 Implement <code>src/core/constants.rs</code>","text":"<p>Status: \u2705 Already provided</p> <p>Validation: Ensure all constants match astronomical standards</p> <pre><code>#[test]\nfn test_constants() {\n    // Synodic month should be ~29.53 days\n    assert!((SYNODIC_MONTH - 29.53).abs() &lt; 0.01);\n\n    // Tropical year should be ~365.24 days\n    assert!((TROPICAL_YEAR - 365.24).abs() &lt; 0.01);\n\n    // Full circle\n    assert_eq!(FULL_CIRCLE, 360.0);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#phase-2-solar-calculations-week-2","title":"Phase 2: Solar Calculations (Week 2)","text":"<p>Priority: HIGH</p>"},{"location":"DEVELOPMENT_GUIDE/#321-implement-srcsolarpositionrs","title":"3.2.1 Implement <code>src/solar/position.rs</code>","text":"<p>Mathematical Foundation: Jean Meeus Chapter 25</p> <p>Required Functions:</p> <pre><code>impl SolarCalculator {\n    /// Mean longitude of Sun\n    /// Accuracy: \u00b10.01 degrees\n    /// Reference: Meeus eq. 25.2\n    pub fn mean_longitude(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // L0 = 280.46646\u00b0 + 36000.76983\u00b0T + 0.0003032\u00b0T\u00b2\n        let l0 = 280.46646 + 36000.76983 * t + 0.0003032 * t * t;\n\n        normalize_degrees(l0)\n    }\n\n    /// Mean anomaly of Sun\n    /// Accuracy: \u00b10.01 degrees\n    /// Reference: Meeus eq. 25.3\n    pub fn mean_anomaly(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // M = 357.52911\u00b0 + 35999.05029\u00b0T - 0.0001537\u00b0T\u00b2\n        let m = 357.52911 + 35999.05029 * t - 0.0001537 * t * t;\n\n        normalize_degrees(m)\n    }\n\n    /// Equation of center (Sun)\n    /// Accuracy: \u00b10.001 degrees\n    /// Reference: Meeus eq. 25.4\n    pub fn equation_of_center(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n        let m = Self::mean_anomaly(jd) * DEG_TO_RAD;\n\n        // C = (1.914602\u00b0 - 0.004817\u00b0T - 0.000014\u00b0T\u00b2) sin M\n        //   + (0.019993\u00b0 - 0.000101\u00b0T) sin 2M\n        //   + 0.000289\u00b0 sin 3M\n\n        let c = (1.914602 - 0.004817 * t - 0.000014 * t * t) * m.sin()\n            + (0.019993 - 0.000101 * t) * (2.0 * m).sin()\n            + 0.000289 * (3.0 * m).sin();\n\n        c\n    }\n\n    /// True longitude of Sun\n    /// Accuracy: \u00b10.01 degrees\n    pub fn true_longitude(jd: JulianDay) -&gt; f64 {\n        let l0 = Self::mean_longitude(jd);\n        let c = Self::equation_of_center(jd);\n        normalize_degrees(l0 + c)\n    }\n\n    /// Apparent longitude (with nutation and aberration)\n    /// Accuracy: \u00b10.001 degrees\n    /// Reference: Meeus eq. 25.8, 25.9\n    pub fn apparent_longitude(jd: JulianDay) -&gt; f64 {\n        let true_long = Self::true_longitude(jd);\n        let t = jd.centuries_since_j2000();\n\n        // Nutation in longitude (simplified)\n        // \u03a9 = 125.04\u00b0 - 1934.136\u00b0T\n        let omega = 125.04 - 1934.136 * t;\n        let nutation = -0.00569 - 0.00478 * (omega * DEG_TO_RAD).sin();\n\n        // Aberration = -0.00569\u00b0\n        let aberration = -0.00569;\n\n        normalize_degrees(true_long + nutation + aberration)\n    }\n}\n</code></pre> <p>Validation Tests:</p> <pre><code>#[test]\nfn test_sun_j2000() {\n    // At J2000.0, Sun's mean longitude should be ~280.46\u00b0\n    let jd = JulianDay(J2000_0);\n    let l0 = SolarCalculator::mean_longitude(jd);\n    assert!((l0 - 280.46).abs() &lt; 0.1);\n}\n\n#[test]\nfn test_sun_2020_april() {\n    // April 14, 2020 - Sun should be in Aries (~24\u00b0 in zodiac)\n    let jd = JulianDay::from_gregorian(2020, 4, 14, 12.0);\n    let longitude = SolarCalculator::apparent_longitude(jd);\n\n    // Sun in Aries: 0\u00b0 - 30\u00b0\n    assert!(longitude &gt;= 0.0 &amp;&amp; longitude &lt; 30.0);\n}\n\n#[test]\nfn test_sun_monotonic() {\n    // Sun's longitude should increase monotonically\n    let jd1 = JulianDay::from_gregorian(2020, 1, 1, 0.0);\n    let jd2 = jd1.add_days(1.0);\n\n    let long1 = SolarCalculator::apparent_longitude(jd1);\n    let long2 = SolarCalculator::apparent_longitude(jd2);\n\n    // Sun moves ~1\u00b0 per day\n    let diff = (long2 - long1 + 360.0).rem_euclid(360.0);\n    assert!(diff &gt; 0.9 &amp;&amp; diff &lt; 1.1);\n}\n</code></pre> <p>IMPORTANT NOTES:</p> <ol> <li>Always use <code>normalize_degrees()</code> to keep angles in 0-360 range</li> <li>Convert to radians when using trigonometric functions</li> <li>Use double precision (f64) throughout</li> <li>Reference Meeus equation numbers in comments</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#322-implement-srcsolarsankrantirs","title":"3.2.2 Implement <code>src/solar/sankranti.rs</code>","text":"<p>Purpose: Find exact time when Sun enters a zodiac sign</p> <p>Algorithm: Newton-Raphson iteration</p> <pre><code>use crate::core::{JulianDay, constants::*};\nuse crate::solar::position::SolarCalculator;\n\n/// Find Sankranti (Sun entering zodiac sign)\n/// \n/// # Arguments\n/// * `year` - BS year\n/// * `month` - BS month (1-12)\n/// \n/// # Returns\n/// Julian Day when Sun enters corresponding zodiac sign\n/// \n/// # Algorithm\n/// Uses Newton-Raphson iteration to solve:\n/// SunLongitude(t) = TargetLongitude\n/// \n/// # Accuracy\n/// \u00b110 seconds for simple mode\n/// \u00b11 second for high-precision mode\npub fn find_sankranti(bs_year: i32, bs_month: u8) -&gt; Result&lt;JulianDay, AstroError&gt; {\n    // 1. Validate input\n    if bs_month &lt; 1 || bs_month &gt; 12 {\n        return Err(AstroError::InvalidMonth(bs_month));\n    }\n\n    // 2. Convert BS month to zodiac sign\n    // Baisakh (month 1) = Aries (0\u00b0)\n    // Jestha (month 2) = Taurus (30\u00b0)\n    // etc.\n    let zodiac_sign = bs_month - 1;\n    let target_longitude = (zodiac_sign as f64) * ZODIAC_DEGREES;\n\n    // 3. Initial guess: approximate date from BS year\n    let ad_year_approx = bs_year - 57; // 2000 BS \u2248 1943 AD\n    let ad_month_approx = bs_month as i32; // Rough approximation\n\n    let mut jd = JulianDay::from_gregorian(\n        ad_year_approx, \n        ad_month_approx as u8, \n        15, \n        0.0\n    );\n\n    // 4. Newton-Raphson iteration\n    const MAX_ITERATIONS: usize = 20;\n    const TOLERANCE: f64 = 1.0 / 86400.0; // 1 second in days\n\n    for iteration in 0..MAX_ITERATIONS {\n        let sun_long = SolarCalculator::apparent_longitude(jd);\n\n        // Calculate angular difference (handle 360\u00b0 wrap)\n        let diff = angular_difference(target_longitude, sun_long);\n\n        // Convergence check\n        if diff.abs() &lt; 0.001 { // 0.001\u00b0 \u2248 2.4 seconds\n            return Ok(jd);\n        }\n\n        // Sun moves ~0.985647\u00b0 per day\n        const SUN_DAILY_MOTION: f64 = 0.985647;\n        let dt = diff / SUN_DAILY_MOTION;\n\n        // Update Julian Day\n        jd = jd.add_days(dt);\n\n        // Safety check: shouldn't move more than 60 days\n        if dt.abs() &gt; 60.0 {\n            return Err(AstroError::ConvergenceFailed);\n        }\n    }\n\n    Err(AstroError::MaxIterationsExceeded)\n}\n\n/// Calculate angular difference accounting for 360\u00b0 wrap\n/// Returns value in range [-180, +180]\nfn angular_difference(target: f64, current: f64) -&gt; f64 {\n    let diff = target - current;\n\n    // Normalize to [-180, +180]\n    if diff &gt; 180.0 {\n        diff - 360.0\n    } else if diff &lt; -180.0 {\n        diff + 360.0\n    } else {\n        diff\n    }\n}\n\n/// Error types for astronomical calculations\n#[derive(Debug, Clone, thiserror::Error)]\npub enum AstroError {\n    #[error(\"Invalid month: {0}\")]\n    InvalidMonth(u8),\n\n    #[error(\"Convergence failed\")]\n    ConvergenceFailed,\n\n    #[error(\"Maximum iterations exceeded\")]\n    MaxIterationsExceeded,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sankranti_2077_baisakh() {\n        // 2077 Baisakh 1 (Mesh Sankranti) = April 13, 2020\n        let jd = find_sankranti(2077, 1).unwrap();\n        let (year, month, day, _) = jd.to_gregorian();\n\n        assert_eq!(year, 2020);\n        assert_eq!(month, 4);\n        // Day should be 13 or 14 (depends on exact time)\n        assert!(day &gt;= 13 &amp;&amp; day &lt;= 14);\n    }\n\n    #[test]\n    fn test_all_months_2077() {\n        // All 12 months should have valid Sankranti\n        for month in 1..=12 {\n            let result = find_sankranti(2077, month);\n            assert!(result.is_ok(), \"Failed for month {}\", month);\n        }\n    }\n\n    #[test]\n    fn test_angular_difference() {\n        assert_eq!(angular_difference(10.0, 5.0), 5.0);\n        assert_eq!(angular_difference(5.0, 10.0), -5.0);\n        assert_eq!(angular_difference(10.0, 350.0), 20.0);\n        assert_eq!(angular_difference(350.0, 10.0), -20.0);\n    }\n}\n</code></pre> <p>CRITICAL RULES for Sankranti Finder:</p> <ol> <li>Always handle 360\u00b0 wrap - Use <code>angular_difference()</code> function</li> <li>Limit iteration steps - Prevent infinite loops</li> <li>Use good initial guess - Within \u00b130 days of true date</li> <li>Check convergence - Stop when accuracy achieved</li> <li>Validate results - Ensure Sun actually at target longitude</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#phase-3-lunar-calculations-week-3","title":"Phase 3: Lunar Calculations (Week 3)","text":"<p>Priority: HIGH</p>"},{"location":"DEVELOPMENT_GUIDE/#331-implement-srclunarpositionrs","title":"3.3.1 Implement <code>src/lunar/position.rs</code>","text":"<p>Mathematical Foundation: Jean Meeus Chapter 47 (simplified)</p> <p>Required Functions:</p> <pre><code>impl LunarCalculator {\n    /// Mean longitude of Moon\n    /// Reference: Meeus eq. 47.1\n    pub fn mean_longitude(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // L' = 218.3164477\u00b0 + 481267.88123421\u00b0T \n        //      - 0.0015786\u00b0T\u00b2 + T\u00b3/538841 - T\u2074/65194000\n\n        let l = 218.3164477 \n            + 481267.88123421 * t\n            - 0.0015786 * t * t\n            + t * t * t / 538841.0\n            - t * t * t * t / 65194000.0;\n\n        normalize_degrees(l)\n    }\n\n    /// Mean elongation of Moon\n    /// Reference: Meeus eq. 47.2\n    pub fn mean_elongation(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // D = 297.8501921\u00b0 + 445267.1114034\u00b0T \n        //     - 0.0018819\u00b0T\u00b2 + T\u00b3/545868 - T\u2074/113065000\n\n        let d = 297.8501921\n            + 445267.1114034 * t\n            - 0.0018819 * t * t\n            + t * t * t / 545868.0\n            - t * t * t * t / 113065000.0;\n\n        normalize_degrees(d)\n    }\n\n    /// Mean anomaly of Moon\n    /// Reference: Meeus eq. 47.4\n    pub fn mean_anomaly(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // M' = 134.9633964\u00b0 + 477198.8675055\u00b0T\n        //      + 0.0087414\u00b0T\u00b2 + T\u00b3/69699 - T\u2074/14712000\n\n        let m = 134.9633964\n            + 477198.8675055 * t\n            + 0.0087414 * t * t\n            + t * t * t / 69699.0\n            - t * t * t * t / 14712000.0;\n\n        normalize_degrees(m)\n    }\n\n    /// Simplified true longitude of Moon\n    /// Accuracy: \u00b12\u00b0\n    /// For precise work, use full ELP-2000 theory\n    pub fn true_longitude_simplified(jd: JulianDay) -&gt; f64 {\n        let l = Self::mean_longitude(jd);\n        let d = Self::mean_elongation(jd) * DEG_TO_RAD;\n        let m = Self::mean_anomaly(jd) * DEG_TO_RAD;\n        let m_sun = crate::solar::SolarCalculator::mean_anomaly(jd) * DEG_TO_RAD;\n\n        // Simplified perturbations (largest terms only)\n        let correction = \n            6.288774 * m.sin()\n            + 1.274027 * (2.0 * d - m).sin()\n            + 0.658314 * (2.0 * d).sin()\n            + 0.213618 * (2.0 * m).sin()\n            - 0.185116 * m_sun.sin()\n            - 0.114332 * (2.0 * d - 2.0 * m).sin();\n\n        normalize_degrees(l + correction)\n    }\n}\n</code></pre> <p>Validation Tests:</p> <pre><code>#[test]\nfn test_moon_j2000() {\n    let jd = JulianDay(J2000_0);\n    let longitude = LunarCalculator::mean_longitude(jd);\n    // Moon's mean longitude at J2000.0 should be ~218.3\u00b0\n    assert!((longitude - 218.3).abs() &lt; 1.0);\n}\n\n#[test]\nfn test_moon_moves_faster_than_sun() {\n    let jd = JulianDay::from_gregorian(2020, 1, 1, 0.0);\n    let long1 = LunarCalculator::true_longitude_simplified(jd);\n    let long2 = LunarCalculator::true_longitude_simplified(jd.add_days(1.0));\n\n    let moon_motion = (long2 - long1 + 360.0).rem_euclid(360.0);\n\n    // Moon moves ~13\u00b0 per day\n    assert!(moon_motion &gt; 11.0 &amp;&amp; moon_motion &lt; 15.0);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#332-implement-srclunartithirs","title":"3.3.2 Implement <code>src/lunar/tithi.rs</code>","text":"<p>Purpose: Calculate Tithi (lunar day)</p> <pre><code>/// Calculate Tithi at given Julian Day\n/// \n/// Tithi is defined by elongation of Moon from Sun:\n/// Tithi = floor((MoonLong - SunLong) / 12\u00b0) + 1\n/// \n/// Returns: 1-30 (1-15 = Shukla Paksha, 16-30 = Krishna Paksha)\npub fn calculate_tithi(jd: JulianDay) -&gt; u8 {\n    let sun_long = SolarCalculator::apparent_longitude(jd);\n    let moon_long = LunarCalculator::true_longitude_simplified(jd);\n\n    // Elongation (Moon ahead of Sun)\n    let elongation = (moon_long - sun_long + 360.0).rem_euclid(360.0);\n\n    // Each tithi = 12\u00b0 of elongation\n    let tithi = (elongation / TITHI_DEGREES).floor() as u8 + 1;\n\n    // Should be 1-30\n    if tithi &lt; 1 || tithi &gt; 30 {\n        return 1; // Safety fallback\n    }\n\n    tithi\n}\n\n/// Find when a specific Tithi starts\n/// Returns Julian Day of Tithi beginning\npub fn find_tithi_start(bs_year: i32, bs_month: u8, tithi: u8) -&gt; Result&lt;JulianDay, AstroError&gt; {\n    if tithi &lt; 1 || tithi &gt; 30 {\n        return Err(AstroError::InvalidTithi(tithi));\n    }\n\n    // Target elongation\n    let target_elongation = (tithi as f64 - 1.0) * TITHI_DEGREES;\n\n    // Initial guess: start of month\n    let month_start = crate::solar::find_sankranti(bs_year, bs_month)?;\n    let mut jd = month_start.add_days((tithi as f64 - 1.0) * 0.984); // ~1 day per tithi\n\n    // Newton-Raphson iteration\n    for _ in 0..20 {\n        let sun_long = SolarCalculator::apparent_longitude(jd);\n        let moon_long = LunarCalculator::true_longitude_simplified(jd);\n        let elongation = (moon_long - sun_long + 360.0).rem_euclid(360.0);\n\n        let diff = angular_difference(target_elongation, elongation);\n\n        if diff.abs() &lt; 0.01 {\n            return Ok(jd);\n        }\n\n        // Moon-Sun relative motion: ~12.19\u00b0 per day\n        let dt = diff / 12.19;\n        jd = jd.add_days(dt);\n    }\n\n    Err(AstroError::ConvergenceFailed)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tithi_range() {\n        let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n        let tithi = calculate_tithi(jd);\n        assert!(tithi &gt;= 1 &amp;&amp; tithi &lt;= 30);\n    }\n\n    #[test]\n    fn test_tithi_progression() {\n        // Tithi should increase over time\n        let jd1 = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n        let jd2 = jd1.add_days(1.0);\n\n        let t1 = calculate_tithi(jd1);\n        let t2 = calculate_tithi(jd2);\n\n        // Should advance by 0-2 tithis per day\n        let diff = (t2 as i32 - t1 as i32 + 30) % 30;\n        assert!(diff &gt;= 0 &amp;&amp; diff &lt;= 2);\n    }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#phase-4-calendar-logic-week-4-5","title":"Phase 4: Calendar Logic (Week 4-5)","text":"<p>Priority: MEDIUM</p>"},{"location":"DEVELOPMENT_GUIDE/#341-implement-srccalendarmonth_calculatorrs","title":"3.4.1 Implement <code>src/calendar/month_calculator.rs</code>","text":"<p>Purpose: Calculate BS month length using Sankranti times</p> <pre><code>/// Calculate number of days in BS month\n/// \n/// Algorithm:\n/// 1. Find Sankranti for month N (when Sun enters zodiac sign N)\n/// 2. Find Sankranti for month N+1\n/// 3. Days = floor(Sankranti[N+1] - Sankranti[N])\n/// \n/// # Returns\n/// Number of days (typically 29-32)\npub fn calculate_month_days(bs_year: i32, bs_month: u8) -&gt; Result&lt;u8, AstroError&gt; {\n    // Find start of this month\n    let sankranti_start = find_sankranti(bs_year, bs_month)?;\n\n    // Find start of next month\n    let (next_year, next_month) = if bs_month == 12 {\n        (bs_year + 1, 1)\n    } else {\n        (bs_year, bs_month + 1)\n    };\n\n    let sankranti_end = find_sankranti(next_year, next_month)?;\n\n    // Calculate days\n    let days = sankranti_end.diff_days(&amp;sankranti_start);\n    let days_int = days.round() as u8;\n\n    // Sanity check\n    if days_int &lt; 29 || days_int &gt; 32 {\n        return Err(AstroError::InvalidMonthLength(days_int));\n    }\n\n    Ok(days_int)\n}\n\n/// Generate complete BS calendar for a year\npub fn generate_year_calendar(bs_year: i32) -&gt; Result&lt;[u8; 12], AstroError&gt; {\n    let mut calendar = [0u8; 12];\n\n    for month in 1..=12 {\n        calendar[(month - 1) as usize] = calculate_month_days(bs_year, month)?;\n    }\n\n    Ok(calendar)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_month_length_range() {\n        let days = calculate_month_days(2077, 1).unwrap();\n        assert!(days &gt;= 29 &amp;&amp; days &lt;= 32);\n    }\n\n    #[test]\n    fn test_year_total_days() {\n        let calendar = generate_year_calendar(2077).unwrap();\n        let total: u32 = calendar.iter().map(|&amp;d| d as u32).sum();\n\n        // BS year should be 354-385 days\n        assert!(total &gt;= 354 &amp;&amp; total &lt;= 385);\n    }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#phase-5-validation-week-6","title":"Phase 5: Validation (Week 6)","text":"<p>Priority: CRITICAL</p>"},{"location":"DEVELOPMENT_GUIDE/#351-create-validation-framework","title":"3.5.1 Create Validation Framework","text":"<pre><code>// tests/validation.rs\n\nuse npdatetime_astronomical::prelude::*;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\n/// Load known data from CSV\nfn load_csv_data(path: &amp;str) -&gt; Vec&lt;(i32, u8, u8)&gt; {\n    let file = File::open(path).unwrap();\n    let reader = BufReader::new(file);\n\n    let mut data = Vec::new();\n\n    for line in reader.lines().skip(1) { // Skip header\n        let line = line.unwrap();\n        let parts: Vec&lt;&amp;str&gt; = line.split(',').collect();\n\n        let year: i32 = parts[0].parse().unwrap();\n        let month: u8 = parts[1].parse().unwrap();\n        let days: u8 = parts[2].parse().unwrap();\n\n        data.push((year, month, days));\n    }\n\n    data\n}\n\n#[test]\nfn validate_against_csv() {\n    let csv_data = load_csv_data(\"../npdatetime/data/calendar_bs.csv\");\n\n    let mut matches = 0;\n    let mut mismatches = Vec::new();\n\n    for (year, month, expected_days) in csv_data {\n        let calculated_days = calculate_month_days(year, month).unwrap();\n\n        if calculated_days == expected_days {\n            matches += 1;\n        } else {\n            mismatches.push((year, month, expected_days, calculated_days));\n        }\n    }\n\n    // Print results\n    println!(\"Validation Results:\");\n    println!(\"Matches: {}\", matches);\n    println!(\"Mismatches: {}\", mismatches.len());\n\n    if !mismatches.is_empty() {\n        println!(\"\\nMismatches:\");\n        for (y, m, exp, calc) in &amp;mismatches {\n            println!(\"  {}/{}: Expected {}, Got {}\", y, m, exp, calc);\n        }\n    }\n\n    // Should match 100%\n    assert_eq!(mismatches.len(), 0, \"Astronomical calculations don't match CSV\");\n}\n\n#[test]\nfn validate_sankranti_times() {\n    // Known Mesh Sankranti times (Baisakh 1)\n    let known_sankranti = vec![\n        (2077, 1, (2020, 4, 13)), // 2077 Baisakh 1 = April 13-14, 2020\n        (2078, 1, (2021, 4, 14)),\n        (2079, 1, (2022, 4, 14)),\n        (2080, 1, (2023, 4, 14)),\n        (2081, 1, (2024, 4, 13)),\n    ];\n\n    for (bs_year, bs_month, (ad_year, ad_month, ad_day)) in known_sankranti {\n        let jd = find_sankranti(bs_year, bs_month).unwrap();\n        let (y, m, d, _) = jd.to_gregorian();\n\n        // Allow \u00b11 day difference (time zone effects)\n        assert!(\n            (y == ad_year &amp;&amp; m == ad_month &amp;&amp; (d as i32 - ad_day as i32).abs() &lt;= 1),\n            \"Sankranti mismatch for {}/{}: Expected {}/{}/{}, Got {}/{}/{}\",\n            bs_year, bs_month, ad_year, ad_month, ad_day, y, m, d\n        );\n    }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#4-code-standards","title":"4. Code Standards","text":""},{"location":"DEVELOPMENT_GUIDE/#41-documentation","title":"4.1 Documentation","text":"<p>RULE 5: Every public function must have documentation</p> <pre><code>/// Calculate Sun's true longitude\n/// \n/// # Arguments\n/// * `jd` - Julian Day in Terrestrial Time\n/// \n/// # Returns\n/// Sun's geocentric true longitude in degrees (0-360)\n/// \n/// # Accuracy\n/// \u00b10.01 degrees (simple mode)\n/// \u00b10.001 degrees (high-precision mode)\n/// \n/// # Reference\n/// Jean Meeus, \"Astronomical Algorithms\", Chapter 25\n/// \n/// # Example\n/// ```\n/// let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n/// let longitude = SolarCalculator::true_longitude(jd);\n/// assert!(longitude &gt;= 0.0 &amp;&amp; longitude &lt; 360.0);\n/// ```\npub fn true_longitude(jd: JulianDay) -&gt; f64 {\n    // Implementation\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#42-error-handling","title":"4.2 Error Handling","text":"<p>RULE 6: Use Result for fallible operations <pre><code>// CORRECT: Return Result\npub fn find_sankranti(year: i32, month: u8) -&gt; Result&lt;JulianDay, AstroError&gt; {\n    if month &lt; 1 || month &gt; 12 {\n        return Err(AstroError::InvalidMonth(month));\n    }\n    // ...\n}\n\n// WRONG: Panic on error\npub fn find_sankranti(year: i32, month: u8) -&gt; JulianDay {\n    assert!(month &gt;= 1 &amp;&amp; month &lt;= 12); // Don't do this!\n    // ...\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#43-testing","title":"4.3 Testing","text":"<p>RULE 7: Every module needs tests</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Unit tests\n    #[test]\n    fn test_basic_functionality() { }\n\n    // Edge cases\n    #[test]\n    fn test_boundary_conditions() { }\n\n    // Integration tests\n    #[test]\n    fn test_with_other_modules() { }\n\n    // Validation tests\n    #[test]\n    fn test_against_known_values() { }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#44-performance","title":"4.4 Performance","text":"<p>RULE 8: Avoid unnecessary allocations</p> <pre><code>// CORRECT: Stack allocation\nfn normalize_degrees(angle: f64) -&gt; f64 {\n    angle.rem_euclid(360.0)\n}\n\n// WRONG: Heap allocation\nfn normalize_degrees(angle: f64) -&gt; Box&lt;f64&gt; {\n    Box::new(angle.rem_euclid(360.0)) // Unnecessary!\n}\n</code></pre> <p>RULE 9: Cache expensive calculations</p> <pre><code>// CORRECT: Calculate once\nlet sun_long = SolarCalculator::apparent_longitude(jd);\nlet value1 = process(sun_long);\nlet value2 = transform(sun_long);\n\n// WRONG: Calculate twice\nlet value1 = process(SolarCalculator::apparent_longitude(jd));\nlet value2 = transform(SolarCalculator::apparent_longitude(jd)); // Wasteful!\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#5-mathematical-foundations","title":"5. Mathematical Foundations","text":""},{"location":"DEVELOPMENT_GUIDE/#51-coordinate-systems","title":"5.1 Coordinate Systems","text":"<p>IMPORTANT: Understand these coordinate systems:</p> <ol> <li>Ecliptic Coordinates - Longitude measured along ecliptic (used for Sun, Moon)</li> <li>Equatorial Coordinates - Right Ascension and Declination (not used in BS calendar)</li> <li>Zodiac Signs - 30\u00b0 divisions starting from Spring Equinox</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#52-time-scales","title":"5.2 Time Scales","text":"<p>CRITICAL: Distinguish between time scales:</p> <ol> <li>UTC - Coordinated Universal Time (user input/output)</li> <li>TT (Terrestrial Time) - Uniform time scale (calculations)</li> <li>NPT - Nepal Time (UTC + 5:45)</li> </ol> <pre><code>// CORRECT: Convert to TT for calculations\nlet utc_jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\nlet tt_jd = utc_to_tt(utc_jd); // Add ~70 seconds\nlet sun_long = SolarCalculator::apparent_longitude(tt_jd);\n\n// WRONG: Use UTC directly\nlet sun_long = SolarCalculator::apparent_longitude(utc_jd); // Inaccurate!\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#53-precision-requirements","title":"5.3 Precision Requirements","text":"<p>Accuracy Targets:</p> <ul> <li>Solar longitude: \u00b10.01\u00b0 (\u00b140 arcseconds)</li> <li>Lunar longitude: \u00b10.1\u00b0 (\u00b16 arcminutes)</li> <li>Sankranti time: \u00b110 seconds</li> <li>Tithi time: \u00b11 minute</li> <li>Month length: Exact integer days</li> </ul>"},{"location":"DEVELOPMENT_GUIDE/#6-implementation-details","title":"6. Implementation Details","text":""},{"location":"DEVELOPMENT_GUIDE/#61-newton-raphson-method","title":"6.1 Newton-Raphson Method","text":"<p>Algorithm for finding events:</p> <pre><code>1. Make initial guess: x\u2080\n2. Calculate f(x\u2080) - current value\n3. Calculate f'(x\u2080) - derivative (rate of change)\n4. Update: x\u2081 = x\u2080 - f(x\u2080)/f'(x\u2080)\n5. Repeat until |f(x)| &lt; tolerance\n</code></pre> <p>For Sankranti: - f(t) = SunLongitude(t) - TargetLongitude - f'(t) \u2248 0.985647\u00b0/day (Sun's daily motion)</p> <p>For Tithi: - f(t) = MoonLongitude(t) - SunLongitude(t) - TargetElongation - f'(t) \u2248 12.19\u00b0/day (Moon-Sun relative motion)</p>"},{"location":"DEVELOPMENT_GUIDE/#62-angle-normalization","title":"6.2 Angle Normalization","text":"<p>CRITICAL: Always normalize angles</p> <pre><code>/// Normalize angle to [0, 360) degrees\nfn normalize_degrees(angle: f64) -&gt; f64 {\n    angle.rem_euclid(360.0)\n}\n\n/// Calculate angular difference with wrap-around\n/// Returns value in [-180, 180]\nfn angular_difference(target: f64, current: f64) -&gt; f64 {\n    let diff = target - current;\n    if diff &gt; 180.0 {\n        diff - 360.0\n    } else if diff &lt; -180.0 {\n        diff + 360.0\n    } else {\n        diff\n    }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#63-trigonometric-functions","title":"6.3 Trigonometric Functions","text":"<p>RULE 10: Always convert degrees to radians</p> <pre><code>// CORRECT\nlet m_rad = mean_anomaly * DEG_TO_RAD;\nlet correction = amplitude * m_rad.sin();\n\n// WRONG\nlet correction = amplitude * mean_anomaly.sin(); // Using degrees!\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#7-testing-strategy","title":"7. Testing Strategy","text":""},{"location":"DEVELOPMENT_GUIDE/#71-unit-tests","title":"7.1 Unit Tests","text":"<p>Test each function independently:</p> <pre><code>#[test]\nfn test_mean_longitude() {\n    let jd = JulianDay(J2000_0);\n    let l0 = SolarCalculator::mean_longitude(jd);\n    assert!((l0 - 280.46).abs() &lt; 0.01);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#72-integration-tests","title":"7.2 Integration Tests","text":"<p>Test module interactions:</p> <pre><code>#[test]\nfn test_sankranti_to_month_days() {\n    let days = calculate_month_days(2077, 1).unwrap();\n    assert!(days &gt;= 29 &amp;&amp; days &lt;= 32);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#73-validation-tests","title":"7.3 Validation Tests","text":"<p>Compare against known data:</p> <pre><code>#[test]\nfn test_against_csv_data() {\n    // Load CSV and compare\n    // Must match 100%\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#74-regression-tests","title":"7.4 Regression Tests","text":"<p>Prevent breaking changes:</p> <pre><code>#[test]\nfn test_regression_2077() {\n    // Known results for 2077\n    let expected = [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31];\n    let calculated = generate_year_calendar(2077).unwrap();\n    assert_eq!(calculated, expected);\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#8-performance-requirements","title":"8. Performance Requirements","text":""},{"location":"DEVELOPMENT_GUIDE/#81-benchmarks","title":"8.1 Benchmarks","text":"<p>Create benchmarks for critical functions:</p> <pre><code>// benches/astronomical_bench.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn bench_sun_longitude(c: &amp;mut Criterion) {\n    let jd = JulianDay::from_gregorian(2020, 4, 14, 0.0);\n\n    c.bench_function(\"sun_longitude\", |b| {\n        b.iter(|| SolarCalculator::apparent_longitude(black_box(jd)))\n    });\n}\n\nfn bench_find_sankranti(c: &amp;mut Criterion) {\n    c.bench_function(\"find_sankranti\", |b| {\n        b.iter(|| find_sankranti(black_box(2077), black_box(1)))\n    });\n}\n\nfn bench_month_calculation(c: &amp;mut Criterion) {\n    c.bench_function(\"calculate_month_days\", |b| {\n        b.iter(|| calculate_month_days(black_box(2077), black_box(1)))\n    });\n}\n\ncriterion_group!(benches, bench_sun_longitude, bench_find_sankranti, bench_month_calculation);\ncriterion_main!(benches);\n</code></pre> <p>Performance Targets: - Sun position: &lt; 1 \u00b5s - Moon position: &lt; 5 \u00b5s - Find Sankranti: &lt; 10 ms - Calculate month: &lt; 50 ms</p>"},{"location":"DEVELOPMENT_GUIDE/#9-validation-process","title":"9. Validation Process","text":""},{"location":"DEVELOPMENT_GUIDE/#91-data-sources-for-validation","title":"9.1 Data Sources for Validation","text":"<ol> <li>Your CSV file - Primary validation source</li> <li>Nepal government calendars - Official BS dates</li> <li>Online converters - Cross-check (e.g., ashesh.com.np)</li> <li>Astronomical almanacs - Solar/lunar positions</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#92-validation-checklist","title":"9.2 Validation Checklist","text":"<p>Before considering implementation complete:</p> <ul> <li>[ ] All 2077 BS months match CSV exactly</li> <li>[ ] All 2000-2090 BS months match CSV (100%)</li> <li>[ ] Sankranti times within \u00b110 seconds of known values</li> <li>[ ] Year totals 354-385 days</li> <li>[ ] No month &lt; 29 or &gt; 32 days</li> <li>[ ] Lunar positions within \u00b12\u00b0 of almanac</li> <li>[ ] Solar positions within \u00b10.01\u00b0 of VSOP87</li> </ul>"},{"location":"DEVELOPMENT_GUIDE/#10-common-pitfalls","title":"10. Common Pitfalls","text":""},{"location":"DEVELOPMENT_GUIDE/#101-angle-wrap-around","title":"10.1 Angle Wrap-Around","text":"<p>PITFALL: Forgetting 360\u00b0 wrap</p> <pre><code>// WRONG: Direct subtraction\nlet diff = target_longitude - sun_longitude;\nif diff &lt; 0.0 { diff += 360.0; } // Incomplete!\n\n// CORRECT: Use angular_difference()\nlet diff = angular_difference(target_longitude, sun_longitude);\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#102-time-scale-confusion","title":"10.2 Time Scale Confusion","text":"<p>PITFALL: Mixing UTC and TT</p> <pre><code>// WRONG: Using UTC for astronomical calculations\nlet jd_utc = JulianDay::from_gregorian(2020, 4, 14, 0.0);\nlet sun_long = SolarCalculator::apparent_longitude(jd_utc); // Wrong!\n\n// CORRECT: Convert to TT\nlet jd_tt = utc_to_tt(jd_utc);\nlet sun_long = SolarCalculator::apparent_longitude(jd_tt);\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#103-degrees-vs-radians","title":"10.3 Degrees vs Radians","text":"<p>PITFALL: Forgetting conversion</p> <pre><code>// WRONG: Using degrees in sin()\nlet value = amplitude * angle.sin(); // If angle is in degrees!\n\n// CORRECT: Convert first\nlet angle_rad = angle * DEG_TO_RAD;\nlet value = amplitude * angle_rad.sin();\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#104-iteration-limits","title":"10.4 Iteration Limits","text":"<p>PITFALL: Infinite loops</p> <pre><code>// WRONG: No limit\nwhile diff.abs() &gt; tolerance {\n    // Update...\n} // Could loop forever!\n\n// CORRECT: Maximum iterations\nfor iteration in 0..MAX_ITERATIONS {\n    if diff.abs() &lt; tolerance { break; }\n    // Update...\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#105-precision-loss","title":"10.5 Precision Loss","text":"<p>PITFALL: Using f32 instead of f64</p> <pre><code>// WRONG: Single precision\nfn sun_longitude(jd: f32) -&gt; f32 { } // Not enough precision!\n\n// CORRECT: Double precision\nfn sun_longitude(jd: f64) -&gt; f64 { } // Required for astronomy\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#11-debugging-guide","title":"11. Debugging Guide","text":""},{"location":"DEVELOPMENT_GUIDE/#111-debug-output","title":"11.1 Debug Output","text":"<p>Add debug logging:</p> <pre><code>#[cfg(debug_assertions)]\nprintln!(\"Debug: JD={}, SunLong={:.6}\u00b0, Diff={:.6}\u00b0\", \n         jd.0, sun_long, diff);\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#112-comparison-tool","title":"11.2 Comparison Tool","text":"<p>Create comparison tool:</p> <pre><code>fn compare_with_lookup(year: i32) {\n    println!(\"Year {}:\", year);\n    println!(\"Month | Calculated | CSV | Match\");\n    println!(\"------|------------|-----|------\");\n\n    for month in 1..=12 {\n        let calc = calculate_month_days(year, month).unwrap();\n        let csv = load_csv_value(year, month);\n        let match_char = if calc == csv { \"\u2713\" } else { \"\u2717\" };\n\n        println!(\"{:5} | {:10} | {:3} | {}\", \n                 month, calc, csv, match_char);\n    }\n}\n</code></pre>"},{"location":"DEVELOPMENT_GUIDE/#12-deployment-checklist","title":"12. Deployment Checklist","text":"<p>Before releasing:</p> <ul> <li>[ ] All tests passing</li> <li>[ ] 100% CSV validation match</li> <li>[ ] Documentation complete</li> <li>[ ] Examples working</li> <li>[ ] Benchmarks run</li> <li>[ ] No unwrap() in library code</li> <li>[ ] Error messages helpful</li> <li>[ ] README updated</li> <li>[ ] CHANGELOG updated</li> <li>[ ] Version bumped</li> </ul>"},{"location":"DEVELOPMENT_GUIDE/#13-future-enhancements","title":"13. Future Enhancements","text":"<p>After basic implementation works:</p> <ol> <li>High-Precision Mode - Full VSOP87/ELP-2000</li> <li>Leap Month Detection - Adhik Maas logic</li> <li>Nakshatra Calculator - 27 lunar mansions</li> <li>Panchang Generator - Complete almanac</li> <li>Eclipse Predictor - Solar/lunar eclipses</li> <li>Festival Calculator - Religious dates</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#14-references","title":"14. References","text":""},{"location":"DEVELOPMENT_GUIDE/#141-essential-books","title":"14.1 Essential Books","text":"<ol> <li>Jean Meeus - \"Astronomical Algorithms\" (2nd edition, 1998)</li> <li>Chapter 7: Julian Day</li> <li>Chapter 25: Solar Coordinates</li> <li> <p>Chapter 47: Lunar Coordinates</p> </li> <li> <p>Peter Duffett-Smith - \"Practical Astronomy with Your Calculator\"</p> </li> <li> <p>Montenbruck &amp; Pfleger - \"Astronomy on the Personal Computer\"</p> </li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#142-online-resources","title":"14.2 Online Resources","text":"<ol> <li>VSOP87 Data: ftp://ftp.imcce.fr/pub/ephem/planets/vsop87/</li> <li>JPL Horizons: https://ssd.jpl.nasa.gov/horizons/ (validation)</li> <li>PyMeeus: https://github.com/architest/pymeeus (reference implementation)</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#143-test-data-sources","title":"14.3 Test Data Sources","text":"<ol> <li>Your CSV file: <code>npdatetime/data/calendar_bs.csv</code></li> <li>Nepal calendar websites</li> <li>Astronomical almanacs</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#15-support-and-questions","title":"15. Support and Questions","text":"<p>When you encounter issues:</p> <ol> <li>Check this guide first - Most answers are here</li> <li>Test incrementally - Don't write everything at once</li> <li>Validate frequently - Run tests after each function</li> <li>Compare with references - Use Meeus book formulas</li> <li>Ask for help - With specific error messages and context</li> </ol>"},{"location":"DEVELOPMENT_GUIDE/#final-notes","title":"Final Notes","text":"<p>Remember: - This is a research/validation tool, not a production calculator - Lookup tables are faster and proven accurate - Astronomical calculations are complex - take your time - Validate everything - astronomy is unforgiving of errors - Have fun learning - this is fascinating science!</p> <p>Success Criteria: When your calculations match the CSV 100%, you've succeeded!</p> <p>Good luck with your implementation! \ud83d\ude80\ud83c\udf19\u2600\ufe0f</p>"},{"location":"IMPLEMENTATION_GUIDE/","title":"NPDateTime Project Implementation Guide","text":"<p>Based on Your Current Structure</p>"},{"location":"IMPLEMENTATION_GUIDE/#current-status-analysis","title":"\ud83c\udfaf Current Status Analysis","text":"<p>Your project has: - \u2705 Lookup table implementation (<code>src/lookup/</code>) - \u2705 Astronomical calculator skeleton (<code>src/astronomical/</code>) - \u2705 CSV data (<code>data/calendar_bs.csv</code>) - \u2705 Build script (<code>build.rs</code>) - \u2705 Benchmarks (showing performance comparisons) - \u2705 Examples (both basic and astronomical) - \u2705 Bindings structure ready for multiple languages</p>"},{"location":"IMPLEMENTATION_GUIDE/#what-to-implement-next","title":"\ud83d\udccb What to Implement Next","text":""},{"location":"IMPLEMENTATION_GUIDE/#priority-1-complete-astronomical-calculator-core","title":"Priority 1: Complete Astronomical Calculator Core","text":""},{"location":"IMPLEMENTATION_GUIDE/#file-srcastronomicalsolarpositionrs","title":"File: <code>src/astronomical/solar/position.rs</code>","text":"<pre><code>//! Solar position calculations using simplified VSOP87\n//! Reference: Jean Meeus \"Astronomical Algorithms\" Chapter 25\n\nuse crate::astronomical::core::{JulianDay, constants::*};\n\npub struct SolarCalculator;\n\nimpl SolarCalculator {\n    /// Calculate Sun's mean longitude\n    /// Meeus eq. 25.2\n    pub fn mean_longitude(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // L0 = 280.46646\u00b0 + 36000.76983\u00b0T + 0.0003032\u00b0T\u00b2\n        let l0 = 280.46646 + 36000.76983 * t + 0.0003032 * t * t;\n\n        normalize_degrees(l0)\n    }\n\n    /// Calculate Sun's mean anomaly\n    /// Meeus eq. 25.3\n    pub fn mean_anomaly(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n\n        // M = 357.52911\u00b0 + 35999.05029\u00b0T - 0.0001537\u00b0T\u00b2\n        let m = 357.52911 + 35999.05029 * t - 0.0001537 * t * t;\n\n        normalize_degrees(m)\n    }\n\n    /// Calculate equation of center\n    /// Meeus eq. 25.4\n    pub fn equation_of_center(jd: JulianDay) -&gt; f64 {\n        let t = jd.centuries_since_j2000();\n        let m = Self::mean_anomaly(jd) * DEG_TO_RAD;\n\n        let c = (1.914602 - 0.004817 * t - 0.000014 * t * t) * m.sin()\n            + (0.019993 - 0.000101 * t) * (2.0 * m).sin()\n            + 0.000289 * (3.0 * m).sin();\n\n        c\n    }\n\n    /// Calculate Sun's true longitude\n    pub fn true_longitude(jd: JulianDay) -&gt; f64 {\n        let l0 = Self::mean_longitude(jd);\n        let c = Self::equation_of_center(jd);\n        normalize_degrees(l0 + c)\n    }\n\n    /// Calculate Sun's apparent longitude\n    /// Includes nutation and aberration\n    pub fn apparent_longitude(jd: JulianDay) -&gt; f64 {\n        let true_long = Self::true_longitude(jd);\n        let t = jd.centuries_since_j2000();\n\n        // Simplified nutation\n        let omega = 125.04 - 1934.136 * t;\n        let nutation = -0.00569 - 0.00478 * (omega * DEG_TO_RAD).sin();\n\n        normalize_degrees(true_long + nutation)\n    }\n}\n\n/// Normalize angle to [0, 360) degrees\nfn normalize_degrees(angle: f64) -&gt; f64 {\n    angle.rem_euclid(360.0)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sun_mean_longitude_j2000() {\n        let jd = JulianDay(J2000_0);\n        let l0 = SolarCalculator::mean_longitude(jd);\n        assert!((l0 - 280.46).abs() &lt; 0.1);\n    }\n\n    #[test]\n    fn test_sun_2020_april() {\n        // April 14, 2020 - Sun should be in Aries\n        let jd = JulianDay::from_gregorian(2020, 4, 14, 12.0);\n        let longitude = SolarCalculator::apparent_longitude(jd);\n        assert!(longitude &gt;= 0.0 &amp;&amp; longitude &lt; 30.0);\n    }\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#file-srcastronomicalsolarsankrantirs","title":"File: <code>src/astronomical/solar/sankranti.rs</code>","text":"<pre><code>//! Sankranti calculation - finding when Sun enters zodiac signs\n\nuse crate::astronomical::core::{JulianDay, constants::*};\nuse crate::astronomical::solar::position::SolarCalculator;\nuse crate::core::error::NpDateTimeError;\n\npub type Result&lt;T&gt; = std::result::Result&lt;T, NpDateTimeError&gt;;\n\n/// Find when Sun enters a specific zodiac sign\n/// \n/// # Arguments\n/// * `bs_year` - Bikram Sambat year\n/// * `bs_month` - Bikram Sambat month (1-12)\n/// \n/// # Returns\n/// Julian Day when Sun enters the corresponding zodiac sign\npub fn find_sankranti(bs_year: i32, bs_month: u8) -&gt; Result&lt;JulianDay&gt; {\n    if bs_month &lt; 1 || bs_month &gt; 12 {\n        return Err(NpDateTimeError::InvalidMonth);\n    }\n\n    // BS month maps to zodiac sign\n    // Baisakh (1) = Aries (0\u00b0), Jestha (2) = Taurus (30\u00b0), etc.\n    let zodiac_index = bs_month - 1;\n    let target_longitude = (zodiac_index as f64) * ZODIAC_DEGREES;\n\n    // Initial guess: approximate Gregorian date\n    let approx_ad_year = bs_year - 57;\n    let approx_ad_month = bs_month;\n\n    let mut jd = JulianDay::from_gregorian(\n        approx_ad_year,\n        approx_ad_month,\n        14,\n        0.0\n    );\n\n    // Newton-Raphson iteration\n    const MAX_ITERATIONS: usize = 20;\n    const TOLERANCE: f64 = 0.001; // 0.001\u00b0 \u2248 2.4 seconds\n\n    for iteration in 0..MAX_ITERATIONS {\n        let sun_long = SolarCalculator::apparent_longitude(jd);\n        let diff = angular_difference(target_longitude, sun_long);\n\n        // Check convergence\n        if diff.abs() &lt; TOLERANCE {\n            return Ok(jd);\n        }\n\n        // Sun moves ~0.985647\u00b0 per day\n        const SUN_DAILY_MOTION: f64 = 0.985647;\n        let dt = diff / SUN_DAILY_MOTION;\n\n        // Update Julian Day\n        jd = jd.add_days(dt);\n\n        // Safety check\n        if dt.abs() &gt; 60.0 {\n            return Err(NpDateTimeError::CalculationError(\n                \"Sankranti iteration diverged\".into()\n            ));\n        }\n    }\n\n    Err(NpDateTimeError::CalculationError(\n        \"Max iterations exceeded\".into()\n    ))\n}\n\n/// Calculate angular difference accounting for 360\u00b0 wrap\nfn angular_difference(target: f64, current: f64) -&gt; f64 {\n    let diff = target - current;\n\n    if diff &gt; 180.0 {\n        diff - 360.0\n    } else if diff &lt; -180.0 {\n        diff + 360.0\n    } else {\n        diff\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sankranti_2077_baisakh() {\n        // 2077 Baisakh 1 should be around April 13-14, 2020\n        let jd = find_sankranti(2077, 1).unwrap();\n        let (year, month, day, _) = jd.to_gregorian();\n\n        assert_eq!(year, 2020);\n        assert_eq!(month, 4);\n        assert!(day &gt;= 13 &amp;&amp; day &lt;= 14);\n    }\n\n    #[test]\n    fn test_angular_difference() {\n        assert_eq!(angular_difference(10.0, 5.0), 5.0);\n        assert_eq!(angular_difference(5.0, 10.0), -5.0);\n        assert_eq!(angular_difference(10.0, 350.0), 20.0);\n        assert_eq!(angular_difference(350.0, 10.0), -20.0);\n    }\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#file-srcastronomicalcorenewton_raphsonrs","title":"File: <code>src/astronomical/core/newton_raphson.rs</code>","text":"<pre><code>//! Newton-Raphson iteration utilities\n\n/// Generic Newton-Raphson solver\n/// \n/// Solves f(x) = 0 using iteration: x_{n+1} = x_n - f(x_n)/f'(x_n)\npub struct NewtonRaphson&lt;F, FPrime&gt;\nwhere\n    F: Fn(f64) -&gt; f64,\n    FPrime: Fn(f64) -&gt; f64,\n{\n    f: F,\n    f_prime: FPrime,\n    max_iterations: usize,\n    tolerance: f64,\n}\n\nimpl&lt;F, FPrime&gt; NewtonRaphson&lt;F, FPrime&gt;\nwhere\n    F: Fn(f64) -&gt; f64,\n    FPrime: Fn(f64) -&gt; f64,\n{\n    pub fn new(f: F, f_prime: FPrime) -&gt; Self {\n        Self {\n            f,\n            f_prime,\n            max_iterations: 50,\n            tolerance: 1e-6,\n        }\n    }\n\n    pub fn with_tolerance(mut self, tolerance: f64) -&gt; Self {\n        self.tolerance = tolerance;\n        self\n    }\n\n    pub fn with_max_iterations(mut self, max_iter: usize) -&gt; Self {\n        self.max_iterations = max_iter;\n        self\n    }\n\n    pub fn solve(&amp;self, initial_guess: f64) -&gt; Option&lt;f64&gt; {\n        let mut x = initial_guess;\n\n        for _ in 0..self.max_iterations {\n            let fx = (self.f)(x);\n\n            if fx.abs() &lt; self.tolerance {\n                return Some(x);\n            }\n\n            let fpx = (self.f_prime)(x);\n\n            if fpx.abs() &lt; 1e-12 {\n                // Derivative too small\n                return None;\n            }\n\n            x = x - fx / fpx;\n        }\n\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_solve_quadratic() {\n        // Solve x\u00b2 - 4 = 0 (should give x = 2)\n        let solver = NewtonRaphson::new(\n            |x| x * x - 4.0,\n            |x| 2.0 * x,\n        );\n\n        let root = solver.solve(1.0).unwrap();\n        assert!((root - 2.0).abs() &lt; 1e-6);\n    }\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#priority-2-implement-month-calculator","title":"Priority 2: Implement Month Calculator","text":""},{"location":"IMPLEMENTATION_GUIDE/#file-srcastronomicalcalendarmonth_calculatorrs","title":"File: <code>src/astronomical/calendar/month_calculator.rs</code>","text":"<pre><code>//! Calculate BS month lengths using astronomical methods\n\nuse crate::astronomical::solar::sankranti::find_sankranti;\nuse crate::astronomical::core::JulianDay;\nuse crate::core::error::NpDateTimeError;\n\npub type Result&lt;T&gt; = std::result::Result&lt;T, NpDateTimeError&gt;;\n\n/// Calculate number of days in a BS month astronomically\npub fn calculate_month_days(bs_year: i32, bs_month: u8) -&gt; Result&lt;u8&gt; {\n    // Find Sankranti for this month\n    let sankranti_start = find_sankranti(bs_year, bs_month)?;\n\n    // Find Sankranti for next month\n    let (next_year, next_month) = if bs_month == 12 {\n        (bs_year + 1, 1)\n    } else {\n        (bs_year, bs_month + 1)\n    };\n\n    let sankranti_end = find_sankranti(next_year, next_month)?;\n\n    // Calculate difference in days\n    let days = sankranti_end.diff_days(&amp;sankranti_start);\n    let days_int = days.round() as u8;\n\n    // Sanity check\n    if days_int &lt; 29 || days_int &gt; 32 {\n        return Err(NpDateTimeError::CalculationError(\n            format!(\"Invalid month length: {}\", days_int)\n        ));\n    }\n\n    Ok(days_int)\n}\n\n/// Generate complete calendar for a year\npub fn generate_year_calendar(bs_year: i32) -&gt; Result&lt;[u8; 12]&gt; {\n    let mut calendar = [0u8; 12];\n\n    for month in 1..=12 {\n        calendar[(month - 1) as usize] = calculate_month_days(bs_year, month)?;\n    }\n\n    Ok(calendar)\n}\n\n/// Get detailed year information\npub struct YearInfo {\n    pub year: i32,\n    pub months: [u8; 12],\n    pub total_days: u16,\n    pub sankranti_times: Vec&lt;(u8, JulianDay)&gt;,\n}\n\nimpl YearInfo {\n    pub fn calculate(bs_year: i32) -&gt; Result&lt;Self&gt; {\n        let months = generate_year_calendar(bs_year)?;\n        let total_days: u16 = months.iter().map(|&amp;d| d as u16).sum();\n\n        let mut sankranti_times = Vec::with_capacity(12);\n        for month in 1..=12 {\n            let jd = find_sankranti(bs_year, month)?;\n            sankranti_times.push((month, jd));\n        }\n\n        Ok(YearInfo {\n            year: bs_year,\n            months,\n            total_days,\n            sankranti_times,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_month_length_range() {\n        let days = calculate_month_days(2077, 1).unwrap();\n        assert!(days &gt;= 29 &amp;&amp; days &lt;= 32);\n    }\n\n    #[test]\n    fn test_year_total() {\n        let calendar = generate_year_calendar(2077).unwrap();\n        let total: u32 = calendar.iter().map(|&amp;d| d as u32).sum();\n\n        // BS year should be 354-385 days\n        assert!(total &gt;= 354 &amp;&amp; total &lt;= 385);\n    }\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#priority-3-create-validation-example","title":"Priority 3: Create Validation Example","text":""},{"location":"IMPLEMENTATION_GUIDE/#file-examplesastronomicalvalidate_astronomicalrs","title":"File: <code>examples/astronomical/validate_astronomical.rs</code>","text":"<pre><code>//! Validate astronomical calculations against lookup table data\n\nuse npdatetime::astronomical::calendar::month_calculator;\nuse npdatetime::lookup;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Validating Astronomical Calculations\");\n    println!(\"=====================================\\n\");\n\n    // Load CSV data\n    let csv_data = load_csv_data(\"data/calendar_bs.csv\")?;\n\n    let mut matches = 0;\n    let mut mismatches = Vec::new();\n    let mut errors = Vec::new();\n\n    // Test range: 2077 (reduce for faster testing)\n    let test_year = 2077;\n\n    println!(\"Testing year {}...\", test_year);\n\n    for month in 1..=12 {\n        // Get expected value from CSV/lookup\n        let expected = lookup::days_in_month(test_year, month)?;\n\n        // Calculate astronomically\n        match month_calculator::calculate_month_days(test_year, month) {\n            Ok(calculated) =&gt; {\n                if calculated == expected {\n                    matches += 1;\n                    print!(\"\u2713\");\n                } else {\n                    mismatches.push((test_year, month, expected, calculated));\n                    print!(\"\u2717\");\n                }\n            }\n            Err(e) =&gt; {\n                errors.push((test_year, month, e.to_string()));\n                print!(\"E\");\n            }\n        }\n    }\n\n    println!(\"\\n\");\n    println!(\"Results:\");\n    println!(\"--------\");\n    println!(\"Matches: {}\", matches);\n    println!(\"Mismatches: {}\", mismatches.len());\n    println!(\"Errors: {}\", errors.len());\n\n    if !mismatches.is_empty() {\n        println!(\"\\nMismatches:\");\n        for (y, m, exp, calc) in &amp;mismatches {\n            println!(\"  {}/{}: Expected {}, Got {}\", y, m, exp, calc);\n        }\n    }\n\n    if !errors.is_empty() {\n        println!(\"\\nErrors:\");\n        for (y, m, err) in &amp;errors {\n            println!(\"  {}/{}: {}\", y, m, err);\n        }\n    }\n\n    Ok(())\n}\n\nfn load_csv_data(path: &amp;str) -&gt; Result&lt;Vec&lt;(i32, u8, u8)&gt;, Box&lt;dyn std::error::Error&gt;&gt; {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n\n    let mut data = Vec::new();\n\n    for (idx, line) in reader.lines().enumerate() {\n        if idx == 0 {\n            continue; // Skip header\n        }\n\n        let line = line?;\n        let parts: Vec&lt;&amp;str&gt; = line.split(',').collect();\n\n        if parts.len() &gt;= 3 {\n            let year: i32 = parts[0].parse()?;\n            let month: u8 = parts[1].parse()?;\n            let days: u8 = parts[2].parse()?;\n\n            data.push((year, month, days));\n        }\n    }\n\n    Ok(data)\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#priority-4-update-your-error-types","title":"Priority 4: Update Your Error Types","text":""},{"location":"IMPLEMENTATION_GUIDE/#file-srccoreerrorrs","title":"File: <code>src/core/error.rs</code>","text":"<p>Add astronomical-specific errors:</p> <pre><code>#[derive(Debug, Clone, thiserror::Error)]\npub enum NpDateTimeError {\n    #[error(\"Invalid date: {0}\")]\n    InvalidDate(String),\n\n    #[error(\"Invalid month\")]\n    InvalidMonth,\n\n    #[error(\"Out of range: {0}\")]\n    OutOfRange(String),\n\n    #[error(\"Parse error: {0}\")]\n    ParseError(String),\n\n    // NEW: Astronomical errors\n    #[error(\"Calculation error: {0}\")]\n    CalculationError(String),\n\n    #[error(\"Convergence failed\")]\n    ConvergenceFailed,\n\n    #[error(\"Maximum iterations exceeded\")]\n    MaxIterationsExceeded,\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#priority-5-wire-everything-together","title":"Priority 5: Wire Everything Together","text":""},{"location":"IMPLEMENTATION_GUIDE/#file-srcastronomicalmodrs","title":"File: <code>src/astronomical/mod.rs</code>","text":"<pre><code>//! Astronomical calculations for Bikram Sambat calendar\n\npub mod core;\npub mod solar;\npub mod lunar;\npub mod calendar;\n\n// Re-exports\npub use calendar::month_calculator;\npub use solar::sankranti;\n\n/// Main astronomical API\npub struct AstronomicalCalculator;\n\nimpl AstronomicalCalculator {\n    /// Calculate month length using astronomical methods\n    pub fn calculate_month_days(year: i32, month: u8) -&gt; crate::core::error::Result&lt;u8&gt; {\n        calendar::month_calculator::calculate_month_days(year, month)\n    }\n\n    /// Find Sankranti time\n    pub fn find_sankranti(year: i32, month: u8) -&gt; crate::core::error::Result&lt;core::JulianDay&gt; {\n        solar::sankranti::find_sankranti(year, month)\n    }\n\n    /// Generate complete year calendar\n    pub fn generate_year(year: i32) -&gt; crate::core::error::Result&lt;[u8; 12]&gt; {\n        calendar::month_calculator::generate_year_calendar(year)\n    }\n}\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"IMPLEMENTATION_GUIDE/#run-your-tests","title":"Run Your Tests","text":"<pre><code># Test lookup table (should already work)\ncargo test --lib lookup\n\n# Test astronomical calculations (after implementing above)\ncargo test --lib astronomical\n\n# Run validation example\ncargo run --example validate_astronomical\n\n# Run benchmarks\ncargo bench\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#expected-results","title":"\ud83d\udcca Expected Results","text":"<p>After implementation, you should see:</p> <pre><code>Validating Astronomical Calculations\n=====================================\n\nTesting year 2077...\n\u2713\u2713\u2713\u2713\u2713\u2713\u2713\u2713\u2713\u2713\u2713\u2713\n\nResults:\n--------\nMatches: 12\nMismatches: 0\nErrors: 0\n</code></pre>"},{"location":"IMPLEMENTATION_GUIDE/#next-steps-after-this","title":"\ud83c\udfaf Next Steps After This","text":"<ol> <li>Extend validation to more years (2000-2090)</li> <li>Implement lunar calculations for Tithi</li> <li>Add leap month detection</li> <li>Complete Python bindings in <code>bindings/python/</code></li> <li>Build WASM for JavaScript in <code>bindings/javascript/</code></li> </ol>"},{"location":"IMPLEMENTATION_GUIDE/#important-notes","title":"\ud83d\udea8 Important Notes","text":""},{"location":"IMPLEMENTATION_GUIDE/#when-following-the-guidelines","title":"When Following the Guidelines","text":"<ol> <li>Always reference Meeus equations in comments</li> <li>Keep modules independent - solar shouldn't depend on lunar</li> <li>Use Result for all fallible operations <li>Test incrementally - don't write all code at once</li> <li>Validate against CSV frequently</li>"},{"location":"IMPLEMENTATION_GUIDE/#code-quality-checklist","title":"Code Quality Checklist","text":"<ul> <li>[ ] All public functions documented</li> <li>[ ] Meeus equation numbers cited</li> <li>[ ] Unit tests written</li> <li>[ ] Integration tests pass</li> <li>[ ] Benchmarks run</li> <li>[ ] Validated against CSV data</li> </ul>"},{"location":"IMPLEMENTATION_GUIDE/#files-you-need-to-createmodify","title":"\ud83d\udcc1 Files You Need to Create/Modify","text":"<p>Based on your structure, focus on:</p> <ol> <li>\u2705 <code>src/astronomical/solar/position.rs</code> - CREATE</li> <li>\u2705 <code>src/astronomical/solar/sankranti.rs</code> - CREATE</li> <li>\u2705 <code>src/astronomical/core/newton_raphson.rs</code> - CREATE</li> <li>\u2705 <code>src/astronomical/calendar/month_calculator.rs</code> - MODIFY</li> <li>\u2705 <code>src/core/error.rs</code> - MODIFY (add astronomical errors)</li> <li>\u2705 <code>examples/astronomical/validate_astronomical.rs</code> - CREATE</li> </ol>"},{"location":"IMPLEMENTATION_GUIDE/#learning-path","title":"\ud83c\udf93 Learning Path","text":"<ol> <li>Week 1: Implement solar position and Sankranti</li> <li>Week 2: Wire up month calculator and validate</li> <li>Week 3: Optimize and fix any mismatches</li> <li>Week 4: Document and create examples</li> </ol> <p>This gives you a complete, working astronomical calculator that validates against your CSV data!</p>"},{"location":"PROJECT_STRUCTURE/","title":"NPDateTime Unified Project Structure","text":"<p>Combining lookup tables (fast, accurate) with astronomical calculations (future-proof, educational).</p>"},{"location":"PROJECT_STRUCTURE/#complete-directory-structure","title":"\ud83d\udcc1 Complete Directory Structure","text":"<pre><code>npdatetime-rust/\n\u251c\u2500\u2500 Cargo.toml                    # Fixed configuration\n\u251c\u2500\u2500 build.rs                      # Compile-time CSV \u2192 Rust conversion\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 .gitignore\n\u2502\n\u251c\u2500\u2500 CONTRIBUTING.md               # Guide for contributors\n\u2502\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 calendar_bs.csv           # Source of truth (2000-2090 BS)\n\u2502   \u251c\u2500\u2500 calendar_bs.json          # Generated for reference\n\u2502   \u2514\u2500\u2500 validation/\n\u2502       \u251c\u2500\u2500 known_events.json     # Known Sankranti dates for validation\n\u2502       \u2514\u2500\u2500 test_cases.csv        # Test cases for both methods\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs                    # Main library entry\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 lookup/                   # Fast lookup table approach\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs                # Lookup module\n\u2502   \u2502   \u251c\u2500\u2500 data.rs               # Embedded calendar data\n\u2502   \u2502   \u251c\u2500\u2500 converter.rs          # BS \u2194 AD conversion\n\u2502   \u2502   \u2514\u2500\u2500 compressed.rs         # Optional: compressed storage\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 astronomical/             # Astronomical calculation approach\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs                # Astronomical module\n\u2502   \u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 constants.rs      # Astronomical constants\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 time.rs           # Julian Day, time conversions\n\u2502   \u2502   \u251c\u2500\u2500 solar/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 position.rs       # Sun position (VSOP87)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 sankranti.rs      # Solar events\n\u2502   \u2502   \u251c\u2500\u2500 lunar/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 position.rs       # Moon position (ELP-2000)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 tithi.rs          # Lunar days\n\u2502   \u2502   \u2514\u2500\u2500 calendar.rs           # Month length calculator\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 core/                     # Shared core types\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 date.rs               # NepaliDate struct\n\u2502   \u2502   \u251c\u2500\u2500 datetime.rs           # NepaliDateTime struct\n\u2502   \u2502   \u251c\u2500\u2500 error.rs              # Error types\n\u2502   \u2502   \u2514\u2500\u2500 format.rs             # Formatting &amp; parsing\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u251c\u2500\u2500 validation.rs         # Validation utilities\n\u2502       \u2514\u2500\u2500 interpolation.rs      # Math utilities\n\u2502\n\u251c\u2500\u2500 bindings/\n\u2502   \u251c\u2500\u2500 python/                   # Python bindings (PyO3)\n\u2502   \u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 lib.rs\n\u2502   \u2502   \u2514\u2500\u2500 tests/\n\u2502   \u2502       \u2514\u2500\u2500 test_python.py\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 javascript/               # JavaScript/WASM bindings\n\u2502   \u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2502   \u251c\u2500\u2500 package.json\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 lib.rs\n\u2502   \u2502   \u2514\u2500\u2500 examples/\n\u2502   \u2502       \u2514\u2500\u2500 react-example/\n\u2502   \u2502\n\u2502   \u2502\u2500\u2500 java/                     # Java JNI bindings\n\u2502   \u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 lib.rs\n\u2502   \u2502   \u2514\u2500\u2500 java/\n\u2502   \u2502       \u2514\u2500\u2500 NepaliDate.java\n\u2502   \u2502\n\u2502   \u2502\u2500\u2500 php/                      # PHP bindings\n\u2502   \u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 lib.rs\n\u2502   \u2502   \u2514\u2500\u2500 examples/\n\u2502   \u2502       \u2514\u2500\u2500 example.php\n\u2502   \u2502\n\u2502\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 basic_usage.rs            # Basic usage with lookup\n\u2502   \u251c\u2500\u2500 conversion_demo.rs        # BS \u2194 AD conversions\n\u2502   \u251c\u2500\u2500 formatting.rs             # Date formatting\n\u2502   \u251c\u2500\u2500 compare_methods.rs        # Compare lookup vs astronomical\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 astronomical/             # Astronomical examples\n\u2502       \u251c\u2500\u2500 calculate_sankranti.rs\n\u2502       \u251c\u2500\u2500 calculate_tithi.rs\n\u2502       \u2514\u2500\u2500 generate_calendar.rs\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 integration_tests.rs      # Integration tests\n\u2502   \u251c\u2500\u2500 lookup_tests.rs           # Lookup table tests\n\u2502   \u251c\u2500\u2500 astronomical_tests.rs     # Astronomical calculation tests\n\u2502   \u2514\u2500\u2500 validation_tests.rs       # Cross-validation tests\n\u2502\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 date_conversion.rs        # Benchmark conversions\n\u2502   \u2514\u2500\u2500 astronomical_bench.rs     # Benchmark calculations\n\u2502\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 ROADMAP.md                # Project status and future plans\n    \u251c\u2500\u2500 DEVELOPMENT_GUIDE.md      # Implementation guidelines\n    \u251c\u2500\u2500 IMPLEMENTATION_GUIDE.md   # Step-by-step implementation guide\n    \u251c\u2500\u2500 PROJECT_STRUCTURE.md      # This file\n    \u2514\u2500\u2500 ASTRONOMY.md              # Theory behind calculations\n</code></pre>"},{"location":"PROJECT_STRUCTURE/#key-files","title":"\ud83d\udd27 Key Files","text":""},{"location":"PROJECT_STRUCTURE/#buildrs-compile-time-data-embedding","title":"<code>build.rs</code> (Compile-time Data Embedding)","text":"<pre><code>// build.rs\nuse std::env;\nuse std::fs::{File, create_dir_all};\nuse std::io::Write;\nuse std::path::Path;\n\nfn main() {\n    println!(\"cargo:rerun-if-changed=data/calendar_bs.csv\");\n\n    let out_dir = env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(&amp;out_dir).join(\"calendar_data.rs\");\n\n    // Read CSV and generate Rust code\n    let mut reader = csv::Reader::from_path(\"data/calendar_bs.csv\")\n        .expect(\"Failed to read calendar_bs.csv\");\n\n    let mut data = Vec::new();\n\n    for result in reader.records() {\n        let record = result.expect(\"Failed to parse CSV record\");\n        let year: i32 = record[0].parse().expect(\"Invalid year\");\n        let month: u8 = record[1].parse().expect(\"Invalid month\");\n        let days: u8 = record[2].parse().expect(\"Invalid days\");\n\n        data.push((year, month, days));\n    }\n\n    // Generate Rust source code\n    let mut f = File::create(&amp;dest_path).unwrap();\n\n    writeln!(f, \"// Auto-generated from calendar_bs.csv\").unwrap();\n    writeln!(f, \"// DO NOT EDIT MANUALLY\").unwrap();\n    writeln!(f, \"\").unwrap();\n    writeln!(f, \"pub const CALENDAR_DATA: &amp;[(i32, u8, u8)] = &amp;[\").unwrap();\n\n    for (year, month, days) in data {\n        writeln!(f, \"    ({}, {}, {}),\", year, month, days).unwrap();\n    }\n\n    writeln!(f, \"];\").unwrap();\n\n    println!(\"cargo:warning=Generated calendar data with {} entries\", \n             reader.position().line());\n}\n</code></pre>"},{"location":"PROJECT_STRUCTURE/#srclibrs-main-entry-point","title":"<code>src/lib.rs</code> (Main Entry Point)","text":"<p><code>rust //! NPDateTime - High-performance Nepali (Bikram Sambat) datetime library //!  //! This library provides two approaches: //! 1. **Lookup Tables** (default): Fast, accurate, works offline //! 2. **Astronomical Calculations** (optional): Future-proof, educational //!  //! # Quick Start //!  //!</code>rust //! use npdatetime::NepaliDate; //!  //! // Create a date //! let date = NepaliDate::new(2077, 5, 19)?; //!  //! // Convert to Gregorian //! let (year, month, day) = date.to_gregorian()?; //!  //! // Format //! println!(\"{}\", date.format(\"%Y-%m-%d\")); //! ```</p>"},{"location":"PROJECT_STRUCTURE/#cfg_attrnotfeature-std-no_std","title":"![cfg_attr(not(feature = \"std\"), no_std)]","text":""},{"location":"PROJECT_STRUCTURE/#cfg_attrdocsrs-featuredoc_cfg","title":"![cfg_attr(docsrs, feature(doc_cfg))]","text":"<p>// Core modules (always available) pub mod core; pub use core::{NepaliDate, NepaliDateTime, NpdatetimeError, Result};</p> <p>// Lookup table module (default)</p>"},{"location":"PROJECT_STRUCTURE/#cfgfeature-lookup-tables","title":"[cfg(feature = \"lookup-tables\")]","text":""},{"location":"PROJECT_STRUCTURE/#cfg_attrdocsrs-doccfgfeature-lookup-tables","title":"[cfg_attr(docsrs, doc(cfg(feature = \"lookup-tables\")))]","text":"<p>pub mod lookup;</p> <p>// Astronomical calculation module (optional)</p>"},{"location":"PROJECT_STRUCTURE/#cfgfeature-astronomical","title":"[cfg(feature = \"astronomical\")]","text":""},{"location":"PROJECT_STRUCTURE/#cfg_attrdocsrs-doccfgfeature-astronomical","title":"[cfg_attr(docsrs, doc(cfg(feature = \"astronomical\")))]","text":"<p>pub mod astronomical;</p> <p>// Utilities pub mod utils;</p> <p>/// Library version pub const VERSION: &amp;str = env!(\"CARGO_PKG_VERSION\");</p> <p>/// Prelude for common imports pub mod prelude {     pub use crate::core::{NepaliDate, NepaliDateTime};     pub use crate::core::NpdatetimeError;</p> <pre><code>#[cfg(feature = \"lookup-tables\")]\npub use crate::lookup::BsCalendar;\n\n#[cfg(feature = \"astronomical\")]\npub use crate::astronomical::{SolarCalculator, LunarCalculator};\n</code></pre> <p>}</p>"},{"location":"PROJECT_STRUCTURE/#cfgtest","title":"[cfg(test)]","text":"<p>mod tests {     use super::*;</p> <pre><code>#[test]\nfn test_version()\n</code></pre>"},{"location":"ROADMAP/","title":"Project Roadmap","text":""},{"location":"ROADMAP/#npdatetime-development-plan","title":"NPDateTime - Development Plan","text":""},{"location":"ROADMAP/#phase-1-core-library-weeks-1-4","title":"\ud83c\udfaf Phase 1: Core Library (Weeks 1-4)","text":""},{"location":"ROADMAP/#code-quality","title":"\u2705 Code Quality","text":""},{"location":"ROADMAP/#11-complete-implementation","title":"1.1 Complete Implementation","text":"<ul> <li>[ ] Lookup table fully working (2000-2090 BS)</li> <li>[ ] All 12 months \u00d7 91 years validated</li> <li>[ ] BS \u2194 AD conversion 100% accurate</li> <li> <p>[ ] Edge cases handled (year boundaries)</p> </li> <li> <p>[ ] Astronomical calculator (optional feature)</p> </li> <li>[ ] Solar position calculations</li> <li>[ ] Sankranti finder</li> <li>[ ] Month length calculator</li> <li> <p>[ ] Validated against lookup table</p> </li> <li> <p>[ ] Core date operations</p> </li> <li>[ ] Date creation and validation</li> <li>[ ] Date arithmetic (add/subtract days)</li> <li>[ ] Date comparison</li> <li>[ ] Formatting (strftime-like)</li> <li>[ ] Parsing (strptime-like)</li> </ul>"},{"location":"ROADMAP/#12-error-handling","title":"1.2 Error Handling","text":"<pre><code>// NO unwrap() in library code (only in tests/examples)\n\u274c let date = parse_date(input).unwrap();\n\u2705 let date = parse_date(input)?;\n\n// Descriptive error messages\n\u274c Err(\"invalid\")\n\u2705 Err(NpDateTimeError::InvalidDate {\n    year: 2077,\n    month: 13,\n    message: \"Month must be between 1 and 12\"\n})\n</code></pre>"},{"location":"ROADMAP/#13-api-design","title":"1.3 API Design","text":"<p>Checklist: - [ ] API is intuitive and follows Rust conventions - [ ] Method names are clear and consistent - [ ] No breaking changes needed after 1.0 - [ ] Follows semver (semantic versioning)</p> <p>Example of good API: <pre><code>// Simple and intuitive\nlet date = NepaliDate::from_ymd(2077, 5, 19)?;\nlet gregorian = date.to_gregorian();\nlet formatted = date.format(\"%Y-%m-%d\");\n\n// Chainable operations\nlet future = NepaliDate::today()?\n    .add_days(30)\n    .add_months(2);\n</code></pre></p>"},{"location":"ROADMAP/#phase-2-documentation-weeks-5-6","title":"\ud83d\udcda Phase 2: Documentation (Weeks 5-6)","text":""},{"location":"ROADMAP/#readmemd-first-impression","title":"\u2705 README.md - First Impression","text":"<p>Your README must have:</p> <pre><code># NPDateTime \ud83c\uddf3\ud83c\uddf5\n\n[![Crates.io](https://img.shields.io/crates/v/npdatetime.svg)](https://crates.io/crates/npdatetime)\n[![Documentation](https://docs.rs/npdatetime/badge.svg)](https://docs.rs/npdatetime)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Build Status](https://github.com/yourusername/npdatetime/workflows/CI/badge.svg)](https://github.com/yourusername/npdatetime/actions)\n\nFast and accurate Nepali (Bikram Sambat) date and time library for Rust.\n\n## \u2728 Features\n\n- \ud83d\ude80 **Blazing Fast** - 100x faster than Python alternatives\n- \ud83c\udfaf **100% Accurate** - Verified against official BS calendar data\n- \ud83c\udf0d **Multi-platform** - Rust, Python, JavaScript, Java bindings\n- \ud83d\udcc5 **Complete BS Calendar** - Supports years 2000-2090 BS\n- \ud83d\udd0d **Astronomical Calculator** - Optional high-precision mode\n- \u26a1 **Zero Dependencies** - Core library has no dependencies\n\n## \ud83d\ude80 Quick Start\n\n### Rust\n\\```rust\nuse npdatetime::NepaliDate;\n\n// Create date\nlet date = NepaliDate::from_ymd(2077, 5, 19)?;\n\n// Convert to Gregorian\nlet gregorian = date.to_gregorian(); // (2020, 9, 4)\n\n// Format\nprintln!(\"{}\", date.format(\"%d %B %Y\")); // \"19 Bhadra 2077\"\n\\```\n\n### Python\n\\```python\nfrom npdatetime import NepaliDate\n\ndate = NepaliDate(2077, 5, 19)\nprint(date.to_gregorian())  # datetime.date(2020, 9, 4)\n\\```\n\n## \ud83d\udce6 Installation\n\n### Rust\n\\```toml\n[dependencies]\nnpdatetime = \"1.0\"\n\\```\n\n### Python\n\\```bash\npip install npdatetime\n\\```\n\n### JavaScript\n\\```bash\nnpm install npdatetime\n\\```\n\n## \ud83d\udcd6 Documentation\n\n- [API Documentation](https://docs.rs/npdatetime)\n- [User Guide](https://npdatetime.readthedocs.io)\n- [Examples](./examples)\n- [Changelog](./CHANGELOG.md)\n\n## \ud83c\udfaf Use Cases\n\n- Web applications with Nepali calendar support\n- Data analysis with Nepali dates\n- Government and business applications in Nepal\n- Historical date conversions\n- Festival and event calculators\n\n## \ud83e\udd1d Contributing\n\nContributions welcome! See [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## \ud83d\udcc4 License\n\nMIT License - see [LICENSE](LICENSE)\n\n## \ud83d\ude4f Acknowledgments\n\n- Based on official Nepal calendar data\n- Astronomical algorithms from Jean Meeus\n- Inspired by [your Python library](https://github.com/4mritGiri/npdatetime)\n</code></pre>"},{"location":"ROADMAP/#api-documentation","title":"\u2705 API Documentation","text":"<p>Every public item needs docs:</p> <pre><code>/// Represents a date in the Bikram Sambat calendar.\n///\n/// The Bikram Sambat (BS) calendar is the official calendar of Nepal.\n/// This type provides methods for creating, manipulating, and formatting\n/// BS dates.\n///\n/// # Examples\n///\n/// ```\n/// use npdatetime::NepaliDate;\n///\n/// // Create a date\n/// let date = NepaliDate::from_ymd(2077, 5, 19)?;\n///\n/// // Convert to Gregorian\n/// let (year, month, day) = date.to_gregorian();\n/// assert_eq!((year, month, day), (2020, 9, 4));\n///\n/// // Format the date\n/// assert_eq!(date.format(\"%Y-%m-%d\"), \"2077-05-19\");\n/// # Ok::&lt;(), npdatetime::Error&gt;(())\n/// ```\n///\n/// # Date Range\n///\n/// Supported range: 2000/01/01 BS to 2090/12/30 BS\npub struct NepaliDate {\n    // ...\n}\n</code></pre> <p>Checklist: - [ ] All public functions documented - [ ] Code examples in documentation - [ ] Examples compile and run (<code>cargo test --doc</code>) - [ ] Module-level documentation explaining purpose</p>"},{"location":"ROADMAP/#user-guide","title":"\u2705 User Guide","text":"<p>Create <code>docs/guide.md</code>:</p> <pre><code># NPDateTime User Guide\n\n## Table of Contents\n1. Installation\n2. Basic Usage\n3. Date Operations\n4. Formatting and Parsing\n5. Timezone Support\n6. Performance Tips\n7. Migration from Other Libraries\n8. FAQ\n\n## 1. Installation\n...\n\n## 2. Basic Usage\n\n### Creating Dates\n...\n\n### Converting Dates\n...\n</code></pre>"},{"location":"ROADMAP/#examples","title":"\u2705 Examples","text":"<p>Create comprehensive examples in <code>examples/</code>:</p> <ul> <li>[ ] <code>examples/basic_usage.rs</code> - Simple date operations</li> <li>[ ] <code>examples/conversion_demo.rs</code> - BS \u2194 AD conversion</li> <li>[ ] <code>examples/formatting.rs</code> - All format options</li> <li>[ ] <code>examples/date_arithmetic.rs</code> - Add/subtract operations</li> <li>[ ] <code>examples/real_world_app.rs</code> - Complete mini-app</li> <li>[ ] <code>examples/performance_comparison.rs</code> - Benchmarks</li> </ul>"},{"location":"ROADMAP/#phase-3-testing-weeks-7-8","title":"\ud83e\uddea Phase 3: Testing (Weeks 7-8)","text":""},{"location":"ROADMAP/#test-coverage","title":"\u2705 Test Coverage","text":"<p>Target: &gt;80% code coverage</p> <pre><code># Install tarpaulin\ncargo install cargo-tarpaulin\n\n# Run coverage\ncargo tarpaulin --out Html --output-dir coverage\n</code></pre> <p>Test pyramid:</p> <pre><code>         /\\\n        /  \\  Unit Tests (70%)\n       /\u2500\u2500\u2500\u2500\\\n      /      \\  Integration Tests (20%)\n     /\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\\n    /          \\  E2E Tests (10%)\n   /\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\\n</code></pre>"},{"location":"ROADMAP/#test-types","title":"\u2705 Test Types","text":""},{"location":"ROADMAP/#unit-tests","title":"Unit Tests","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_date_creation() {\n        let date = NepaliDate::from_ymd(2077, 5, 19).unwrap();\n        assert_eq!(date.year(), 2077);\n        assert_eq!(date.month(), 5);\n        assert_eq!(date.day(), 19);\n    }\n\n    #[test]\n    fn test_invalid_month() {\n        let result = NepaliDate::from_ymd(2077, 13, 1);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_day() {\n        // Month 5 of 2077 has 31 days\n        assert!(NepaliDate::from_ymd(2077, 5, 32).is_err());\n    }\n}\n</code></pre>"},{"location":"ROADMAP/#integration-tests","title":"Integration Tests","text":"<p>Create <code>tests/integration_test.rs</code>:</p> <pre><code>use npdatetime::NepaliDate;\n\n#[test]\nfn test_round_trip_conversion() {\n    // BS \u2192 AD \u2192 BS should give same date\n    let original = NepaliDate::from_ymd(2077, 5, 19).unwrap();\n    let gregorian = original.to_gregorian();\n    let back = NepaliDate::from_gregorian(\n        gregorian.0, \n        gregorian.1, \n        gregorian.2\n    ).unwrap();\n\n    assert_eq!(original, back);\n}\n\n#[test]\nfn test_all_months_all_years() {\n    // Validate entire supported range\n    for year in 2000..=2090 {\n        for month in 1..=12 {\n            let days = NepaliDate::days_in_month(year, month).unwrap();\n            assert!(days &gt;= 29 &amp;&amp; days &lt;= 32);\n\n            // First and last day of month should be valid\n            assert!(NepaliDate::from_ymd(year, month, 1).is_ok());\n            assert!(NepaliDate::from_ymd(year, month, days).is_ok());\n            assert!(NepaliDate::from_ymd(year, month, days + 1).is_err());\n        }\n    }\n}\n</code></pre>"},{"location":"ROADMAP/#property-based-testing","title":"Property-Based Testing","text":"<p>Add <code>proptest</code>:</p> <pre><code>use proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_date_arithmetic_commutative(days in 1..365i32) {\n        let date = NepaliDate::from_ymd(2077, 1, 1).unwrap();\n        let forward_then_back = date.add_days(days).add_days(-days);\n        let back_then_forward = date.add_days(-days).add_days(days);\n        prop_assert_eq!(forward_then_back, back_then_forward);\n    }\n}\n</code></pre> <p>Test Checklist: - [ ] All public APIs tested - [ ] Edge cases covered - [ ] Error cases tested - [ ] Integration tests for workflows - [ ] Property-based tests for invariants - [ ] Fuzz testing for parser</p>"},{"location":"ROADMAP/#phase-4-cicd-week-9","title":"\ud83d\udd27 Phase 4: CI/CD (Week 9)","text":""},{"location":"ROADMAP/#github-actions","title":"\u2705 GitHub Actions","text":"<p>Create <code>.github/workflows/ci.yml</code>:</p> <pre><code>name: CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    name: Test\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        rust: [stable, beta, nightly]\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: actions-rs/toolchain@v1\n        with:\n          toolchain: ${{ matrix.rust }}\n          override: true\n\n      - name: Run tests\n        run: cargo test --all-features\n\n      - name: Run doc tests\n        run: cargo test --doc\n\n  clippy:\n    name: Clippy\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          components: clippy\n          override: true\n      - run: cargo clippy --all-targets --all-features -- -D warnings\n\n  fmt:\n    name: Rustfmt\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          components: rustfmt\n          override: true\n      - run: cargo fmt --all -- --check\n\n  coverage:\n    name: Coverage\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          override: true\n      - uses: actions-rs/tarpaulin@v0.1\n        with:\n          args: '--all-features --workspace --timeout 600 --out Xml'\n      - uses: codecov/codecov-action@v3\n\n  security:\n    name: Security Audit\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions-rs/audit-check@v1\n        with:\n          token: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"ROADMAP/#pre-commit-hooks","title":"\u2705 Pre-commit Hooks","text":"<p>Create <code>.pre-commit-config.yaml</code>:</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: cargo-fmt\n        name: cargo fmt\n        entry: cargo fmt --all -- --check\n        language: system\n        pass_filenames: false\n\n      - id: cargo-clippy\n        name: cargo clippy\n        entry: cargo clippy --all-targets --all-features -- -D warnings\n        language: system\n        pass_filenames: false\n\n      - id: cargo-test\n        name: cargo test\n        entry: cargo test --all-features\n        language: system\n        pass_filenames: false\n</code></pre>"},{"location":"ROADMAP/#phase-5-publishing-week-10","title":"\ud83d\udce6 Phase 5: Publishing (Week 10)","text":""},{"location":"ROADMAP/#cratesio-preparation","title":"\u2705 Crates.io Preparation","text":""},{"location":"ROADMAP/#51-update-cargotoml","title":"5.1 Update <code>Cargo.toml</code>","text":"<pre><code>[package]\nname = \"npdatetime\"\nversion = \"1.0.0\"\nedition = \"2021\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\ndescription = \"Fast and accurate Nepali (Bikram Sambat) date and time library\"\ndocumentation = \"https://docs.rs/npdatetime\"\nhomepage = \"https://github.com/yourusername/npdatetime\"\nrepository = \"https://github.com/yourusername/npdatetime\"\nreadme = \"README.md\"\nlicense = \"MIT\"\nkeywords = [\"nepali\", \"bikram-sambat\", \"calendar\", \"datetime\", \"nepal\"]\ncategories = [\"date-and-time\", \"localization\", \"internationalization\"]\nexclude = [\n    \"/.github\",\n    \"/target\",\n    \"/benches\",\n    \"*.png\",\n]\n\n[package.metadata.docs.rs]\nall-features = true\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n</code></pre>"},{"location":"ROADMAP/#52-versioning-strategy","title":"5.2 Versioning Strategy","text":"<p>Follow Semantic Versioning:</p> <ul> <li>MAJOR (1.x.x): Breaking API changes</li> <li>MINOR (x.1.x): New features, backward compatible</li> <li>PATCH (x.x.1): Bug fixes</li> </ul>"},{"location":"ROADMAP/#53-changelogmd","title":"5.3 CHANGELOG.md","text":"<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [1.0.0] - 2026-01-20\n\n### Added\n- Initial release\n- BS to AD conversion (2000-2090 BS)\n- Date formatting and parsing\n- Date arithmetic operations\n- Astronomical calculator (optional)\n\n### Performance\n- 100x faster than Python alternatives\n- Zero-copy operations where possible\n</code></pre>"},{"location":"ROADMAP/#54-publish-checklist","title":"5.4 Publish Checklist","text":"<ul> <li>[ ] <code>cargo package</code> succeeds without warnings</li> <li>[ ] All tests pass on CI</li> <li>[ ] Documentation builds without errors</li> <li>[ ] CHANGELOG.md updated</li> <li>[ ] Version bumped in Cargo.toml</li> <li>[ ] Git tag created (<code>git tag v1.0.0</code>)</li> <li>[ ] Run <code>cargo publish --dry-run</code></li> <li>[ ] Run <code>cargo publish</code></li> </ul>"},{"location":"ROADMAP/#phase-6-multi-language-bindings-weeks-11-14","title":"\ud83c\udf0d Phase 6: Multi-Language Bindings (Weeks 11-14)","text":""},{"location":"ROADMAP/#python-bindings-pypi","title":"\u2705 Python Bindings (PyPI)","text":"<p>Setup in <code>bindings/python/</code>:</p> <pre><code># pyproject.toml\n[build-system]\nrequires = [\"maturin&gt;=1.0,&lt;2.0\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"npdatetime\"\nversion = \"1.0.0\"\ndescription = \"Fast Nepali datetime library (Rust bindings)\"\nrequires-python = \"&gt;=3.7\"\nclassifiers = [\n    \"Programming Language :: Rust\",\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n]\n\n# src/lib.rs (Python bindings)\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct NepaliDate {\n    inner: npdatetime::NepaliDate,\n}\n\n#[pymethods]\nimpl NepaliDate {\n    #[new]\n    fn new(year: i32, month: u8, day: u8) -&gt; PyResult&lt;Self&gt; {\n        Ok(NepaliDate {\n            inner: npdatetime::NepaliDate::from_ymd(year, month, day)\n                .map_err(|e| PyErr::new::&lt;pyo3::exceptions::PyValueError, _&gt;(\n                    e.to_string()\n                ))?,\n        })\n    }\n\n    fn to_gregorian(&amp;self) -&gt; (i32, u8, u8) {\n        self.inner.to_gregorian()\n    }\n}\n\n#[pymodule]\nfn npdatetime(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_class::&lt;NepaliDate&gt;()?;\n    Ok(())\n}\n</code></pre> <p>Publish: <pre><code>cd bindings/python\nmaturin build --release\nmaturin publish\n</code></pre></p>"},{"location":"ROADMAP/#javascriptwasm-npm","title":"\u2705 JavaScript/WASM (npm)","text":"<pre><code>cd bindings/javascript\nwasm-pack build --target web --release\nwasm-pack publish\n</code></pre>"},{"location":"ROADMAP/#java-bindings-maven-central","title":"\u2705 Java Bindings (Maven Central)","text":"<p>Use JNI - more complex, consider if there's demand.</p>"},{"location":"ROADMAP/#phase-7-marketing-community-weeks-15-16","title":"\ud83c\udfa8 Phase 7: Marketing &amp; Community (Weeks 15-16)","text":""},{"location":"ROADMAP/#create-website","title":"\u2705 Create Website","text":"<p>Options: 1. GitHub Pages (free) 2. Netlify (free) 3. Vercel (free)</p> <p>Content: <pre><code>npdatetime.org/\n\u251c\u2500\u2500 index.html          # Landing page\n\u251c\u2500\u2500 docs/               # Documentation\n\u251c\u2500\u2500 examples/           # Interactive examples\n\u251c\u2500\u2500 playground/         # Try it online (WASM)\n\u2514\u2500\u2500 blog/               # Release announcements\n</code></pre></p>"},{"location":"ROADMAP/#write-launch-blog-post","title":"\u2705 Write Launch Blog Post","text":"<p>Title: \"Introducing NPDateTime: Lightning-Fast Nepali Date Library\"</p> <p>Sections: 1. Problem: Existing solutions are slow/inaccurate 2. Solution: NPDateTime with Rust performance 3. Features: What makes it special 4. Benchmarks: Show 100x speedup 5. Getting Started: Quick examples 6. Roadmap: Future plans</p> <p>Publish on: - Dev.to - Medium - Hacker News - Reddit (r/rust, r/Nepal) - Twitter/X</p>"},{"location":"ROADMAP/#community-building","title":"\u2705 Community Building","text":"<p>Communication Channels: - [ ] GitHub Discussions enabled - [ ] Discord server (optional) - [ ] Twitter/X account - [ ] Stack Overflow tag monitoring</p> <p>Engagement: - [ ] Respond to issues within 24 hours - [ ] Welcome first-time contributors - [ ] Monthly project updates - [ ] Highlight community contributions</p>"},{"location":"ROADMAP/#phase-8-monitoring-maintenance-ongoing","title":"\ud83d\udcca Phase 8: Monitoring &amp; Maintenance (Ongoing)","text":""},{"location":"ROADMAP/#metrics-to-track","title":"\u2705 Metrics to Track","text":"<p>Download Stats: - crates.io downloads - PyPI downloads - npm downloads</p> <p>Quality Metrics: - Test coverage (&gt;80%) - Documentation coverage (100%) - Open issues vs closed - PR response time</p> <p>Community Health: - GitHub stars - Contributors - Forks - Dependencies (dependents)</p>"},{"location":"ROADMAP/#dependency-management","title":"\u2705 Dependency Management","text":"<pre><code># Check for outdated dependencies\ncargo outdated\n\n# Security audit\ncargo audit\n\n# Update dependencies (carefully!)\ncargo update\n</code></pre>"},{"location":"ROADMAP/#release-process","title":"\u2705 Release Process","text":"<p>Every release: 1. Update CHANGELOG.md 2. Bump version in Cargo.toml 3. Run full test suite 4. Update documentation 5. Create git tag 6. Publish to crates.io 7. Publish bindings (Python, JS) 8. Create GitHub release 9. Announce on social media</p>"},{"location":"ROADMAP/#production-grade-checklist-summary","title":"\u2705 Production-Grade Checklist Summary","text":""},{"location":"ROADMAP/#must-have-mvp","title":"Must-Have (MVP)","text":"<ul> <li>[ ] Core functionality complete and tested</li> <li>[ ] Zero <code>unwrap()</code> in library code</li> <li>[ ] Good README with examples</li> <li>[ ] API documentation</li> <li>[ ] CI/CD pipeline</li> <li>[ ] Published to crates.io</li> <li>[ ] MIT License</li> <li>[ ] CHANGELOG.md</li> </ul>"},{"location":"ROADMAP/#should-have-v10","title":"Should-Have (v1.0)","text":"<ul> <li>[ ] &gt;80% test coverage</li> <li>[ ] Multi-platform CI (Linux, Mac, Windows)</li> <li>[ ] User guide</li> <li>[ ] Python bindings</li> <li>[ ] Security audit passes</li> <li>[ ] Clippy/fmt in CI</li> <li>[ ] Comprehensive examples</li> </ul>"},{"location":"ROADMAP/#nice-to-have-v1x","title":"Nice-to-Have (v1.x)","text":"<ul> <li>[ ] JavaScript/WASM bindings</li> <li>[ ] Website with playground</li> <li>[ ] Blog posts</li> <li>[ ] Community Discord</li> <li>[ ] &gt;1000 GitHub stars</li> <li>[ ] Listed on awesome-rust</li> <li>[ ] Conference talk</li> </ul>"},{"location":"ROADMAP/#quick-start-timeline","title":"\ud83d\ude80 Quick Start Timeline","text":"<p>Month 1: Code quality + docs Month 2: Testing + CI/CD Month 3: Publishing + bindings Month 4: Marketing + community</p> <p>By Month 4, you should have: - Production-grade Rust library - Python and JavaScript bindings - 80%+ test coverage - Professional documentation - Active community</p>"},{"location":"ROADMAP/#need-help","title":"\ud83d\udcde Need Help?","text":"<p>Resources: - Rust API Guidelines - The Cargo Book - docs.rs Publishing Guide - PyO3 User Guide - wasm-pack Documentation</p> <p>Communities: - Rust Users Forum - r/rust - Rust Discord</p>"},{"location":"ROADMAP/#success-metrics","title":"\ud83c\udfaf Success Metrics","text":"<p>After 6 months: - 10,000+ downloads - 100+ GitHub stars - 10+ contributors - Used in 5+ production apps - Featured in Rust newsletter</p> <p>After 1 year: - 100,000+ downloads - 500+ stars - De-facto standard for Nepali dates - Multiple language bindings - Active community</p> <p>Good luck building the best Nepali datetime library! \ud83d\ude80\ud83c\uddf3\ud83c\uddf5</p>"},{"location":"guide/","title":"NPDateTime User Guide \ud83c\uddf3\ud83c\uddf5","text":"<p>NPDateTime is a modern, fast, and accurate library for working with the Bikram Sambat (BS) calendar.</p>"},{"location":"guide/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"guide/#installation","title":"Installation","text":"<p>Add this to your <code>Cargo.toml</code>: <pre><code>[dependencies]\nnpdatetime = \"0.1.0\"\n</code></pre></p>"},{"location":"guide/#basic-usage","title":"Basic Usage","text":"<pre><code>use npdatetime::prelude::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Create a date\n    let date = NepaliDate::new(2077, 5, 19)?;\n    println!(\"Standard BS: {}\", date); // 2077-05-19\n\n    // Convert to Gregorian (AD)\n    let (year, month, day) = date.to_gregorian()?;\n    println!(\"AD Date: {}-{:02}-{:02}\", year, month, day); // 2020-09-04\n\n    // Parse from string\n    let parsed = NepaliDate::parse(\"2077-05-19\", \"%Y-%m-%d\")?;\n    assert_eq!(date, parsed);\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/#calendar-logic","title":"\ud83d\udcc5 Calendar Logic","text":"<p>NPDateTime uses a hybrid approach: 1. Lookup Tables: For years 1975 to 2100 BS, it uses pre-validated calendar data for 100% accuracy and maximum speed (~10ns). 2. Astronomical Engine: For future or historical dates outside the lookup range, it can calculate month lengths using VSOP87 (solar) and ELP-2000 (lunar) models.</p>"},{"location":"guide/#using-the-astronomical-engine","title":"Using the Astronomical Engine","text":"<p>Enable the <code>astronomical</code> feature: <pre><code>npdatetime = { version = \"0.1.0\", features = [\"astronomical\"] }\n</code></pre></p> <pre><code>use npdatetime::astronomical::BsCalendar;\n\nlet cal = BsCalendar::new();\nlet info = cal.get_year_info(2081)?;\nprintln!(\"Year 2081 month lengths: {:?}\", info.month_lengths);\n</code></pre>"},{"location":"guide/#features","title":"\ud83d\udee0 Features","text":""},{"location":"guide/#date-arithmetic","title":"Date Arithmetic","text":"<pre><code>let today = NepaliDate::today()?;\nlet next_month = today.add_days(30)?;\nlet previous_week = today.add_days(-7)?;\n</code></pre>"},{"location":"guide/#fiscal-year-and-ordinals-feature-parity","title":"Fiscal Year and Ordinals (Feature Parity)","text":"<p>NPDateTime now includes full parity with the original Python <code>npdatetime</code> library:</p> <pre><code>let date = NepaliDate::new(2080, 4, 15)?;\nprintln!(\"Fiscal Year: {}\", date.fiscal_year());    // \"2080/81\"\nprintln!(\"Quarter: {}\", date.fiscal_quarter());     // 1\n\nlet ordinal = date.to_ordinal();\nlet back = NepaliDate::from_ordinal(ordinal)?;\nassert_eq!(date, back);\n</code></pre>"},{"location":"guide/#formatting-extensive-tokens","title":"Formatting (Extensive Tokens)","text":"Token Description Example <code>%K</code> Devanagari Year \u0968\u0966\u096d\u096d <code>%n</code> Devanagari Month \u0966\u096b <code>%D</code> Devanagari Day \u0967\u096f <code>%N</code> Devanagari Month Name \u092d\u093e\u0926\u094d\u0930 <code>%G</code> Devanagari Weekday \u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930"},{"location":"guide/#visual-calendar","title":"Visual Calendar","text":"<pre><code>let date = NepaliDate::today()?;\nprintln!(\"{}\", date.month_calendar());\n</code></pre>"},{"location":"guide/#tithis-and-sankrantis","title":"Tithis and Sankrantis","text":"<p>Requires <code>astronomical</code> feature: <pre><code>use npdatetime::astronomical::{SankrantiFinder, TithiCalculator};\nuse npdatetime::astronomical::core::JulianDay;\n\nlet jd = JulianDay::from_gregorian(2024, 4, 13, 12.0);\nlet tithi = TithiCalculator::get_tithi(jd);\nprintln!(\"Tithi: {} ({})\", tithi.name(), tithi.paksha);\n</code></pre></p>"},{"location":"guide/#language-bindings","title":"\ud83c\udf0d Language Bindings","text":"<p>NPDateTime is designed to be used everywhere: - Python: <code>pip install npdatetime</code> - JavaScript/WASM: <code>npm install npdatetime-wasm</code> - Java/Stubs: Available in <code>bindings/java</code></p>"},{"location":"guide/#performance-tips","title":"\ud83d\udcca Performance Tips","text":"<ul> <li>Use the default lookup tables for high-volume transactions.</li> <li>Use formatting patterns once or cache formatted strings if needed, though formatting is very fast (&lt;1\u00b5s).</li> <li>Avoid unnecessary round-trips to Gregorian if only BS operations are needed.</li> </ul>"},{"location":"guide/#faq","title":"\u2753 FAQ","text":""},{"location":"guide/#why-use-npdatetime-over-other-libraries","title":"Why use NPDateTime over other libraries?","text":"<p>Most existing libraries for Nepali dates are either inaccurate (using approximations) or slow (reading files at runtime). NPDateTime is verified and embeds data at compile time.</p>"},{"location":"guide/#is-it-no_std-compatible","title":"Is it <code>no_std</code> compatible?","text":"<p>The core library is <code>no_std</code> compatible if you disable the <code>std</code> feature.</p>"},{"location":"guide/#can-i-contribute","title":"Can I contribute?","text":"<p>Yes! See CONTRIBUTING.md.</p>"}]}