// npdatetime - Rust Core Library for Bikram Sambat Calendar
// Based on your Python implementation at github.com/4mritGiri/npdatetime

pub mod core;
pub mod solar;
pub mod lunar;
pub mod calendar;

use std::fmt;

// ============================================================================
// CONSTANTS AND DATA STRUCTURES
// ============================================================================

// Include data generated by build.rs
include!(concat!(env!("OUT_DIR"), "/calendar_data.rs"));

/// Map the generated flat data to the expected format
fn get_bs_month_data() -> Vec<[u8; 12]> {
    let mut result = Vec::new();
    let mut current_year = -1;
    let mut year_data = [0u8; 12];
    
    for &(year, month, days) in BS_CALENDAR_DATA {
        if year != current_year {
            if current_year != -1 {
                result.push(year_data);
            }
            current_year = year;
            year_data = [0u8; 12];
        }
        if month >= 1 && month <= 12 {
            year_data[month as usize - 1] = days;
        }
    }
    result.push(year_data);
    result
}

lazy_static::lazy_static! {
    static ref BS_MONTH_DATA: Vec<[u8; 12]> = get_bs_month_data();
}

/// Ayanamsha (Chitra Paksha/Lahiri) approximation for Nirayana calculations
pub fn get_ayanamsha(jd: crate::core::JulianDay) -> f64 {
    let t = jd.centuries_since_j2000();
    // Lahiri Ayanamsha: 23.852778° at J2000 + secular change
    23.852778 + 1.396971 * t + 0.000308 * t * t
}

/// Reference point: Start of BS 1975
const BS_EPOCH_YEAR: i32 = 1975;
const BS_EPOCH_AD: (i32, u8, u8) = (1918, 4, 13);

/// Month names in Nepali
const NEPALI_MONTHS: [&str; 12] = [
    "Baisakh", "Jestha", "Ashadh", "Shrawan", "Bhadra", "Ashwin",
    "Kartik", "Mangsir", "Poush", "Magh", "Falgun", "Chaitra",
];

/// Month names in Nepali (Devanagari)
const NEPALI_MONTHS_UNICODE: [&str; 12] = [
    "बैशाख", "जेष्ठ", "आषाढ", "श्रावण", "भाद्र", "आश्विन",
    "कार्तिक", "मंसिर", "पौष", "माघ", "फाल्गुन", "चैत्र",
];

/// Weekday names in Nepali
const NEPALI_WEEKDAYS: [&str; 7] = [
    "Aaitabaar", "Sombaar", "Mangalbaar", "Budhabaar",
    "Bihibaar", "Shukrabaar", "Shanibaar",
];

// ============================================================================
// ERROR HANDLING
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
pub enum NepaliDateError {
    InvalidDate(String),
    OutOfRange(String),
    ParseError(String),
}

impl fmt::Display for NepaliDateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            NepaliDateError::InvalidDate(msg) => write!(f, "Invalid date: {}", msg),
            NepaliDateError::OutOfRange(msg) => write!(f, "Out of range: {}", msg),
            NepaliDateError::ParseError(msg) => write!(f, "Parse error: {}", msg),
        }
    }
}

impl std::error::Error for NepaliDateError {}

pub type Result<T> = std::result::Result<T, NepaliDateError>;

// ============================================================================
// NEPALI DATE STRUCTURE
// ============================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct NepaliDate {
    pub year: i32,
    pub month: u8,
    pub day: u8,
}

impl NepaliDate {
    /// Creates a new Nepali date
    pub fn new(year: i32, month: u8, day: u8) -> Result<Self> {
        if month < 1 || month > 12 {
            return Err(NepaliDateError::InvalidDate(
                format!("Month must be between 1 and 12, got {}", month)
            ));
        }

        let max_day = Self::days_in_month(year, month)?;
        if day < 1 || day > max_day {
            return Err(NepaliDateError::InvalidDate(
                format!("Day must be between 1 and {}, got {}", max_day, day)
            ));
        }

        Ok(NepaliDate { year, month, day })
    }

    /// Returns the number of days in a given month
    pub fn days_in_month(year: i32, month: u8) -> Result<u8> {
        if month < 1 || month > 12 {
            return Err(NepaliDateError::InvalidDate(
                format!("Invalid month: {}", month)
            ));
        }

        let index = (year - BS_EPOCH_YEAR) as usize;
        if index >= BS_MONTH_DATA.len() {
            return Err(NepaliDateError::OutOfRange(
                format!("Year {} is out of supported range", year)
            ));
        }

        Ok(BS_MONTH_DATA[index][(month - 1) as usize])
    }

    /// Converts Nepali date to Gregorian date (year, month, day)
    pub fn to_gregorian(&self) -> Result<(i32, u8, u8)> {
        // Calculate total days from epoch
        let mut total_days = 0i64;

        // Add days for complete years
        for y in BS_EPOCH_YEAR..self.year {
            for m in 1..=12 {
                total_days += Self::days_in_month(y, m)? as i64;
            }
        }

        // Add days for complete months in current year
        for m in 1..self.month {
            total_days += Self::days_in_month(self.year, m)? as i64;
        }

        // Add remaining days
        total_days += (self.day - 1) as i64;

        // Convert to Gregorian
        let (mut year, mut month, mut day) = BS_EPOCH_AD;
        let mut days_to_add = total_days;

        while days_to_add > 0 {
            let days_in_current_month = gregorian_days_in_month(year, month);
            if days_to_add >= (days_in_current_month - day + 1) as i64 {
                days_to_add -= (days_in_current_month - day + 1) as i64;
                day = 1;
                month += 1;
                if month > 12 {
                    month = 1;
                    year += 1;
                }
            } else {
                day += days_to_add as u8;
                days_to_add = 0;
            }
        }

        Ok((year, month, day))
    }

    /// Creates a Nepali date from a Gregorian date
    pub fn from_gregorian(year: i32, month: u8, day: u8) -> Result<Self> {
        // Calculate days from BS epoch to given Gregorian date
        let total_days = gregorian_days_since_epoch(year, month, day, BS_EPOCH_AD)?;

        // Convert total days to BS date
        let mut remaining_days = total_days;
        let mut bs_year = BS_EPOCH_YEAR;
        let mut bs_month = 1u8;

        // Find the year
        loop {
            let mut year_days = 0;
            for m in 1..=12 {
                year_days += Self::days_in_month(bs_year, m)? as i64;
            }

            if remaining_days >= year_days {
                remaining_days -= year_days;
                bs_year += 1;
            } else {
                break;
            }
        }

        // Find the month and day
        while bs_month <= 12 {
            let month_days = Self::days_in_month(bs_year, bs_month)? as i64;
            if remaining_days >= month_days {
                remaining_days -= month_days;
                bs_month += 1;
            } else {
                break;
            }
        }

        let bs_day = (remaining_days + 1) as u8;

        Self::new(bs_year, bs_month, bs_day)
    }

    /// Returns today's date in Nepali calendar
    pub fn today() -> Result<Self> {
        use std::time::{SystemTime, UNIX_EPOCH};
        
        let duration = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap();
        
        let days_since_unix_epoch = duration.as_secs() / 86400;
        let (year, month, day) = unix_epoch_to_gregorian(days_since_unix_epoch);
        
        Self::from_gregorian(year, month, day)
    }

    /// Formats the date as a string
    pub fn format(&self, format_str: &str) -> String {
        format_str
            .replace("%Y", &self.year.to_string())
            .replace("%m", &format!("{:02}", self.month))
            .replace("%d", &format!("{:02}", self.day))
            .replace("%B", NEPALI_MONTHS[(self.month - 1) as usize])
            .replace("%b", &NEPALI_MONTHS[(self.month - 1) as usize][..3])
    }

    /// Adds days to the date
    pub fn add_days(&self, days: i32) -> Result<Self> {
        let (g_year, g_month, g_day) = self.to_gregorian()?;
        let total_days = gregorian_to_days(g_year, g_month, g_day) + days as i64;
        let (new_year, new_month, new_day) = days_to_gregorian(total_days);
        Self::from_gregorian(new_year, new_month, new_day)
    }
}

impl fmt::Display for NepaliDate {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}-{:02}-{:02}", self.year, self.month, self.day)
    }
}

// ============================================================================
// GREGORIAN CALENDAR HELPER FUNCTIONS
// ============================================================================

fn is_gregorian_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

fn gregorian_days_in_month(year: i32, month: u8) -> u8 {
    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
        4 | 6 | 9 | 11 => 30,
        2 => if is_gregorian_leap_year(year) { 29 } else { 28 },
        _ => 0,
    }
}

fn gregorian_days_since_epoch(
    year: i32,
    month: u8,
    day: u8,
    epoch: (i32, u8, u8),
) -> Result<i64> {
    let (ey, em, ed) = epoch;
    
    if year < ey || (year == ey && month < em) 
        || (year == ey && month == em && day < ed) {
        return Err(NepaliDateError::OutOfRange(
            "Date is before the BS epoch".to_string()
        ));
    }

    let mut total_days = 0i64;

    // Add days for complete years between epoch and current year
    for y in ey..year {
        total_days += if is_gregorian_leap_year(y) { 366 } else { 365 };
    }

    // Subtract days before epoch in the epoch year
    for m in 1..em {
        total_days -= gregorian_days_in_month(ey, m) as i64;
    }
    total_days -= (ed - 1) as i64;

    // Add days in current year
    for m in 1..month {
        total_days += gregorian_days_in_month(year, m) as i64;
    }
    total_days += (day - 1) as i64;

    Ok(total_days)
}

fn gregorian_to_days(year: i32, month: u8, day: u8) -> i64 {
    let mut days = 0i64;
    
    for y in 1..year {
        days += if is_gregorian_leap_year(y) { 366 } else { 365 };
    }
    
    for m in 1..month {
        days += gregorian_days_in_month(year, m) as i64;
    }
    
    days + day as i64
}

fn days_to_gregorian(mut days: i64) -> (i32, u8, u8) {
    let mut year = 1i32;
    
    loop {
        let year_days = if is_gregorian_leap_year(year) { 366 } else { 365 };
        if days > year_days {
            days -= year_days;
            year += 1;
        } else {
            break;
        }
    }
    
    let mut month = 1u8;
    while month <= 12 {
        let month_days = gregorian_days_in_month(year, month) as i64;
        if days > month_days {
            days -= month_days;
            month += 1;
        } else {
            break;
        }
    }
    
    (year, month, days as u8)
}

fn unix_epoch_to_gregorian(days_since_epoch: u64) -> (i32, u8, u8) {
    let base_days = gregorian_to_days(1970, 1, 1);
    let total_days = base_days + days_since_epoch as i64;
    days_to_gregorian(total_days)
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_valid_date() {
        let date = NepaliDate::new(2077, 5, 19).unwrap();
        assert_eq!(date.year, 2077);
        assert_eq!(date.month, 5);
        assert_eq!(date.day, 19);
    }

    #[test]
    fn test_invalid_month() {
        assert!(NepaliDate::new(2077, 13, 1).is_err());
        assert!(NepaliDate::new(2077, 0, 1).is_err());
    }

    #[test]
    fn test_conversion_to_gregorian() {
        let bs_date = NepaliDate::new(2000, 1, 1).unwrap();
        let ad_date = bs_date.to_gregorian().unwrap();
        assert_eq!(ad_date, (1943, 4, 14));
    }

    #[test]
    fn test_conversion_from_gregorian() {
        let bs_date = NepaliDate::from_gregorian(1943, 4, 14).unwrap();
        assert_eq!(bs_date.year, 2000);
        assert_eq!(bs_date.month, 1);
        assert_eq!(bs_date.day, 1);
    }

    #[test]
    fn test_format() {
        let date = NepaliDate::new(2077, 5, 19).unwrap();
        assert_eq!(date.format("%Y-%m-%d"), "2077-05-19");
        assert_eq!(date.format("%d %B %Y"), "19 Bhadra 2077");
    }

    #[test]
    fn test_display() {
        let date = NepaliDate::new(2077, 5, 19).unwrap();
        assert_eq!(format!("{}", date), "2077-05-19");
    }
}

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

fn main() -> Result<()> {
    // Create a Nepali date
    let nepali_date = NepaliDate::new(2077, 5, 19)?;
    println!("Nepali Date: {}", nepali_date);

    // Convert to Gregorian
    let (year, month, day) = nepali_date.to_gregorian()?;
    println!("Gregorian Date: {}-{:02}-{:02}", year, month, day);

    // Create from Gregorian
    let from_gregorian = NepaliDate::from_gregorian(2020, 9, 4)?;
    println!("From Gregorian: {}", from_gregorian);

    // Format date
    println!("Formatted: {}", nepali_date.format("%d %B %Y"));

    // Get today's date
    let today = NepaliDate::today()?;
    println!("Today in BS: {}", today);

    // Add days
    let future = today.add_days(30)?;
    println!("30 days from today: {}", future);

    Ok(())
}